# 구글 C++ 스타일 가이드

<details markdown="1">
  <summary>Table of Contents</summary>

- [1 배경](#s1-background)
- [2 목표](#s2-goal)
- [3 C++ 버전](#s3-version)
- [4 헤더 파일](#s4-header-files)
    * [4.1 독립적인 헤더](#s4-1-self-contained-headers)
    * [4.2 #define 가드](#s4-2-the-define-guard)
    * [4.3 include](#s4-3-include-what-you-use)
    * [4.4 정방향 선언](#s4-4-forward-declarations)
    * [4.5 인라인 함수](#s4-5-inline-functions)
    * [4.6 포함 이름 및 순서](#s4-6-names-and-order-of-includes)
- [5 범위 지정](#s5-scoping)
    * [5.1 네임스페이스](#s5-1-namespaces)
    * [5.2 내부 연계](#s5-2-internal-linkage)
    * [5.3 정적 멤버 및 전역 함수](#s5-3-nonmember-static-mamber-and-global-function)
    * [5.4 지역 변수](#s5-4-local-variables)
    * [5.5 전역 변수](#s5-5-static-and-global-variables)
        + [5.5.1 파기 결정](#s5-5-1-decsion-on-destruction)
        + [5.5.2 초기화 결정](#s5-5-2-decsion-on-initialization)
    * [5.6 thread_local 변수](#s5-6-thread-local-variables)
- [6 클래스](#s6-classes)
    * [6.1 생성자에서 작업하기](#s6-1-doing-work-in-constructors-declaration-order)
    * [6.2 암시적 변환](#s6-2-implicit-conversions)
    * [6.3 복사 가능 및 이동 가능 유형](#s6-3-copyable-and-movable-types)
    * [6.4 구조체 vs 클래스](#s6-4-structs-vs-classes)
    * [6.5 구조체 vs 쌍/튜플](#s6-5-structs-vs-pairs-and-tuples)
    * [6.6 상속](#s6-6-inheritance)
    * [6.7 오퍼레이터 오버로딩](#s6-7-operator-overloading)
    * [6.8 접근 제어](#s6-8-access-control)
    * [6.9 선언 순서](#s6-9-declaration-order)
- [7 함수](#s7-functions)
    * [7.1 입력 및 출력](#s7-1-inputs-and-outputs)
    * [7.2 짧은 함수 작성](#s7-2-write-short-functions)
    * [7.3 함수 오버로딩](#s7-3-function-overloading)
    * [7.4 기본 인수](#s7-4-default-arguments)
    * [7.5 후행 반환 유형 구문](#s7-5-trailing-return-type-syntax)
- [8 기타 C++ 기능](#s8-orther-c++-features)
    * [8.1 Rvalue 참조](#s8-1-rvalue-references)
    * [8.2 Friends](#s8-2-friends)
    * [8.3 예외 처리](#s8-3-exceptions)
    * [8.4 noexcept](#s8-4-noexcept)
    * [8.5 Run-Time Type Informaint(RTTI)](#s8-5-run-time-type-information)
    * [8.6 캐스팅](#s8-6-casting)
    * [8.7 스트림](#s8-7-streams)
    * [8.8 선행 증가 및 선행 감소](#s8-8-preincrement-and-predecrement)
    * [8.9 const 사용](#s8-9-use-of-const)
    * [8.10 constexpr 사용](#s8-10-use-of-constexpr)
    * [8.11 정수 타입](#s8-11-integer-types)
    * [8.12 64bit 이식성](#s8-12-64-bit-portability)
    * [8.13 전처리기 매크로](#s8-13-preprocessor-macros)
    * [8.14 0 및 nullptr/NULL](#s8-14-0-and-nullptr-null)
    * [8.15 sizeof](#s8-15-sizeof)
    * [8.16 유형공제(자동 포함)](#s8-16-type-deduction)
    * [8.17 템플릿 인자 추론](#s8-17-class-template-argument-deduction)
    * [8.18 지정된 이니셜라이저](#s8-18-designated-initializers)
    * [8.19 람다 표현식](#s8-19-lambda-expressions)
    * [8.20 템플릿 메타프로그래밍](#s8-20-template-metaprogramming)
    * [8.21 boost](#s8-21-boost)
    * [8.22 기타 C++ 기능](#s8-22-orther-c++-features)
    * [8.23 비표준 확장](#s8-23-nonstandard-extensions)
    * [8.24 별칭](#s8-24-aliases)
    * [8.25 Switch 문장](#s8-25-switch-statements)
- [9 포괄적인 언어](#s9-inclusive-language)
- [10 네이밍](#s10-naming)
    * [10.1 일반 명명 규칙](#s10-1-general-naming-rules)
    * [10.2 파일 이름](#s10-2-file-names)
    * [10.3 타입 이름](#s10-3-type-names)
    * [10.4 변수 이름](#s10-4-variable-names)
        + [10.4.1 일반 변수 이름](#s10-4-1-common-variable-names)
        + [10.4.2 클래스 멤버 이름](#s10-4-2-class-data-members)
        + [10.4.3 구조체 멤버 이름](#s10-4-3-struct-data-members)
    * [10.5 상수 이름](#s10-5-constant-names)
    * [10.6 함수 이름](#s10-6-function-names)
    * [10.7 네임스페이스 이름](#s10-7-namespace-names)
    * [10.8 열거자 이름](#s10-8-enumerator-names)
    * [10.9 매크로 이름](#s10-9-macro-names)
    * [10.10 예외 이름 규칙](#s10-10-exceptions-to-namaing-rules)
- [11 주석](#s11-comments)
    * [11.1 주석 스타일](#s11-1-comment-style)
    * [11.2 파일 주석](#s11-2-file-comments)
        + [11.2.1 법적 고지 및 작성자 라인](#s11-2-1-legal-notice-and-author-line)
        + [11.2.2 파일 내용](#s11-2-2-file-contents)
    * [11.3 클래스 주석](#s11-3-class-comments)
    * [11.4 함수 주석](#s11-4-function-comments)
        + [11.4.1 함수 선언](#s11-4-1-function-declarations)
        + [11.4.2 함수 정의](#s11-4-1-function-definitions)
    * [11.5 변수 주석](#s11-5-variable-comments)
        + [11.5.1 클래스 멤버](#s11-5-1-class-data-members)
        + [11.5.2 전역 변수](#s11-5-1-global-variables)
    * [11.6 구현 주석](#s11-6-implementation-comments)
        + [11.6-1 함수 인자 주석](#s11-6-1-function-argument-comments)
        + [11.6-2 금지 사항](#s11-6-1-function-argument-comments)
    * [11.7 구두점, 철자 및 문법](#s11-7-punctuation-spelling-and-grammar)
    * [11.8 TODO 주석](#s11-8-todo-comments)
- [12 서식](#s12-formatting)
    * [12.1 줄 길이](#s12-1-line-length)
    * [12.2 비 ASCII 문자](#s12-2-non-ascll-characters)
    * [12.3 스페이스 vs 탭](#s12-3-space-vs-tabs)
    * [12.4 함수 선언과 정의](#s12-4-function-declarations-and-definitions)
    * [12.5 람다 표현식](#s12-5-lambda-expressions)
    * [12.6 부동 소수점 리터럴](#s12-6-floating-point-literals)
    * [12.7 함수 호출](#s12-7-function-calls)
    * [12.8 중괄호 이니셜라이저 목록 형식](#s12-8-braced-initializer-list-format)
    * [12.9 반복 및 분기문](#s12-9-looping-and-branching-statements)
    * [12.10 포인터 및 참조 표현식](#s12-10-pointer-and-reference-expressions)
    * [12.11 Boolean 표현식](#s12-11-boolean-expressions)
    * [12.12 반환값](#s12-12-return-values)
    * [12.13 변수 및 배열 초기화](#s12-13-variable-and-array-initialization)
    * [12.14 전처리기 지시문](#s12-14-preprocessor-directives)
    * [12.15 클래스 서식](#s12-15-class-format)
    * [12.16 생성자 초기화 목록](#s12-16-constructor-initializer-lists)
    * [12.17 네임스페이스 서식](#s12-17-namespace-formatting)
    * [12.18 가로 공백](#s12-18-horizontal-whitespace)
        + [12.18.1 일반](#s12-18-1-general)
        + [12.18.2 반복 및 조건부](#s12-18-2-loop-and-conditionals)
        + [12.18.3 오퍼레이터](#s12-18-3-operators)
        + [12.18.4 템플릿과 캐스트](#s12-18-4-templates-and-casts)
    * [12.19 세로 공백](#s12-19-vertical-whitespace)
- [13 예외 규칙](#s13-exceptions-to-the-rules)
    * [12.1 기존 부적합 코드](#s13-1-existing-non-conformant-code)
    * [12.2 ](#s13-2-windows-code)

</details>


<a id="s1-background"></a>

## 1 배경

C++은 구글의 여러 오픈소스 프로젝트에서 사용하는 주요한 개발 언어입니다.
모든 C++ 프로그래머가 알고 있듯, C++ 언어는 강력한 기능을 많이 가지고 있으나, 그 강력함은 복잡함을 야기하고 그로 인해 버그가
생기기 쉬운 코드가 되거나 읽고 관리하기 어려운 코드가 될 수 있습니다.

이 가이드의 목표는 C++ 코드에서 해야 할 것과 하지 말아야 할 것을 자세하게 서술해서 복잡함을 관리하는 것입니다. 이러한 규칙들은 코더들이 C++ 언어의 기능들을 계속하여 생산적으로 사용하면서도 기반 코드를
관리가능한 상태로 유지하기 위한 것입니다.

'가독성'이라고도 부르는 '_스타일_'은, 우리의 C++ 코드를 지배하는 컨벤션입니다. 이러한 컨벤션은 단순한 소스 파일 포맷팅보다 훨씬 많은 것을 담고 있기 때문에 _스타일_이라는 용어는 다소 그릇된 명칭입니다.

우리의 기반 코드를 관리할 수 있게 유지하는 한 가지 방법은 _일관성_을 강제하는 것입니다. 어떤 프로그래머라도 남의 코드를 볼 수 있고 쉽게 이해할 수 있는 것은 매우 중요합니다. 일치된 스타일을 유지하고 컨벤션에
따른다는 것은 우리가 더 쉽게 "패턴 매칭"을 사용하여 다양한 기호들이 무엇을 의미하고 어떤 값이 변함없이 참인지를 추측할 수 있다는 것을 의미합니다. 모두가 필수적으로 사용할 숙어와 패턴을 만들면 코드를 이해하는
것이 훨씬 쉬워집니다. 가끔은 어떤 스타일 규칙을 바꾸자는 바람직한 논쟁이 있을 수 있지만, 그럼에도 불구하고 일관성을 유지하기 위해 규칙을 기존대로 유지합니다.

이 가이드가 서술하는 또 다른 이슈는 C++의 기능이 비대해지고 있다는 것입니다. C++은 많은 고급 기능이 있는 거대한 언어입니다. 어떤 경우에 우리는 어떤 기능의 사용을 제한하거나 심지어 금지합니다. 이것은
코드를
간단하게 유지하면서 그 기능들이 흔히 만들 수 있는 문제들과 오류들을 피하기 위해서입니다. 이 가이드는 이러한 기능들을 나열하고 왜 사용이 제한되었는지 설명합니다.

구글에서 개발된 오픈 소스 프로젝트는 이 가이드의 요구사항을 따릅니다.

이 가이드는 C++ 튜토리얼이 아니다. 우리는 독자가 이 언어에 친숙하다고 가정합니다.

<a id="s2-goal"></a>

## 2 목표

이 문서가 있는 이유는 무엇입니까?

이 가이드가 제공해야 하는 몇 가지 핵심 목표가 있습니다. 이것이 모든 개별 규칙의 근간이 되는 근본적인 이유입니다.
이러한 아이디어를 전면에 내세움으로써 우리는 토론의 토대를 마련하고 왜 규칙이 있고 특정 결정이 내려진 이유를 더 넓은 커뮤니티에
더 명확하게 전달하기를 희망합니다. 각 규칙이 제공하는 목표를 이해하면 규칙이 언제 포기될 수 있는지(일부는 포기될 수 있음) 가이드의
규칙을 변경하는 데 어떤 종류의 인수 또는 대안이 필요한지 모든 사람에게 더 명확해야 합니다.

스타일 가이드의 목표는 다음과 같습니다.

- __스타일 규칙은 무거워야 합니다.__  
  스타일 규칙은 모든 엔지니어에게 이를 기억하도록 요청하는 것을 정당화할 만큼 충분히 커야 합니다.
  이점은 규칙 없이 얻을 수 있는 코드베이스와 관련하여 측정되므로 매우 유해한 관행에 대한 규칙은 사람들이 어쨌든 그렇게 하지 않을 가능성이 있는 경우 여전히 작은 이점을 가질 수 있습니다.
  이 원칙은 대부분 우리가 가지고 있는 규칙보다는 우리가 가지고 있지 않은 규칙을 설명합니다. 예를 들어 goto는 다음 원칙 중 많은 부분을 위반하지만 이미 거의 사용하지 않기 때문에 스타일 가이드에서 논의하지
  않습니다.
- __작가가 아닌 독자를 위해 최적화__  
  우리의 코드베이스(및 여기에 제출된 대부분의 개별 구성 요소)는 꽤 오랫동안 계속될 것으로 예상됩니다.
  결과적으로 대부분의 코드를 작성하는 것보다 읽는 데 더 많은 시간이 소요됩니다. 우리는 코드를 작성할 때 용이함보다는 코드베이스에서 코드를 읽고, 유지 관리하고, 디버깅하는 일반 소프트웨어 엔지니어의 경험을 위해
  명시적으로 최적화를 선택합니다.
  "독자를 위한 흔적 남기기"는 이 원칙 특히 일반적인 하위 사항입니다. 코드 스니펫에서 놀랍거나 비정상적인 일이 발생하는 경우(예: 포인터 소유권 이전) 해당 지점에서 독자를 위한 텍스트 힌트를 남깁니다. of
  use는 가치가 있습니다(std::unique_ptr은 호출 사이트에서 소유권 이전을 명확하게 보여줍니다).
- __기존 코드와 일관성 유지__  
  코드베이스 전체에서 한 스타일을 일관되게 사용하면 다른(더 중요한) 문제에 집중할 수 있습니다.
  일관성은 또한 자동화를 허용합니다. 코드의 형식을 지정하거나 #include를 조정하는 도구는 코드가 도구의 기대치와 일치할 때만 제대로 작동합니다. 많은 경우에 "일관성 유지"에 귀속되는 규칙은 "그냥 하나를
  선택하고 걱정하지 마세요"로 귀결됩니다.
  이러한 점에 대해 유연성을 허용하는 잠재적 가치는 사람들이 이에 대해 논쟁하게 하는 비용보다 더 큽니다. 그러나 일관성에는 한계가 있습니다. 명확한 기술적 논쟁이나 장기적인 방향이 없을 때 좋은 타이
  브레이커입니다. 로컬에서 더 많이 적용됩니다(파일당 또는 밀접하게 관련된 인터페이스 집합에 대해).
  일관성은 일반적으로 새로운 스타일의 이점이나 시간이 지남에 따라 코드베이스가 새로운 스타일로 수렴되는 경향을 고려하지 않고 이전 스타일로 작업을 수행하는 정당화로 사용되어서는 안 됩니다.
- __적절한 경우 더 넓은 C++ 커뮤니티와 일관성 유지__
  다른 조직에서 C++를 사용하는 방식과의 일관성은 우리 코드 베이스 내의 일관성과 같은 이유로 가치가 있습니다.
  C++ 표준의 기능이 문제를 해결하거나 일부 관용구가 널리 알려지고 수용되는 경우 해당 기능을 사용하는 것이 좋습니다.
  그러나 때로는 표준 기능과 관용구에 결함이 있거나 코드베이스의 요구 사항을 염두에 두지 않고 설계되었습니다.
  이러한 경우(아래 설명 참조) 표준 기능을 제한하거나 금지하는 것이 적절합니다. 경우에 따라 우리는 C++ 표준에 정의된 라이브러리보다 자체 제작 또는 타사 라이브러리를 선호합니다.
  뛰어난 코드베이스를 표준 인터페이스로 전환하기에는 가치가 충분하지 않기 때문입니다.
- __놀랍거나 위험한 구조를 피하십시오__
  C++에는 생각하는 것보다 더 놀랍거나 위험한 기능이 있습니다.
  이러한 함정에 빠지지 않도록 하기 위해 일부 스타일 가이드 제한이 있습니다.
  스타일 가이드 면제에 제한은 높은 기준이 필요합니다.
  규칙을 면제하면 종종 프로그램 정확성을 직접적으로 손상시킬 위험이 있기 때문입니다.
- __일반 C++ 프로그래머가 까다롭거나 유지하기 어려운 구성을 피하십시오__
  C++에는 코드에 도입되는 복잡성 때문에 일반적으로 적합하지 않을 수 있는 기능이 있습니다.
  널리 사용되는 코드에서는 더 복잡한 언어 구성을 사용하는 것이 더 적합할 수 있습니다.
  더 복잡한 구현의 이점은 사용에 따라 크게 배가되고 복잡성을 이해하는 데 드는 비용은 새로운 부분으로 작업할 때 다시 지불할 필요가 없기 때문입니다.
  코드베이스. 확실하지 않은 경우 프로젝트 리더에게 문의하여 이러한 유형의 규칙에 대한 면제를 요청할 수 있습니다.
  코드 소유권과 팀 멤버십은 시간이 지남에 따라 변경되기 때문에 이것은 우리 코드베이스에 특히 중요합니다.
  일부 코드로 작업하는 모든 사람이 현재 코드를 이해하더라도 그러한 이해가 지금부터 몇 년 동안 유지된다는 보장은 없습니다.
- __우리의 규모를 염두에 두십시오__
  1억 개 이상의 라인과 수천 명의 엔지니어로 구성된 코드베이스에서 한 엔지니어의 일부 실수와 단순화는 많은 비용이 들 수 있습니다.
  예를 들어 전역 네임스페이스를 오염시키는 것을 피하는 것이 특히 중요합니다.
  수억 줄의 코드베이스에서 이름 충돌은 작업하기 어렵고 모든 사람이 전역 네임스페이스에 물건을 넣는 경우 피하기 어렵습니다.
- __필요한 경우 최적화에 양보__
  성능 최적화는 이 문서의 다른 원칙과 충돌하는 경우에도 때때로 필요하고 적절할 수 있습니다.

이 문서의 목적은 합리적인 제한과 함께 최대한의 지침을 제공하는 것입니다. 언제나 그렇듯이 상식과 좋은 취향이 우선되어야 합니다.
이를 통해 우리는 귀하의 개인적 선호도나 팀의 선호도뿐만 아니라 전체 Google C++ 커뮤니티의 확립된 규칙을 구체적으로 참조합니다.
영리하거나 비정상적인 구문을 사용하는 것에 대해 회의적이거나 꺼려하십시오. 금지가 없다는 것은 진행 허가와 동일하지 않습니다.
판단을 내리고 확실하지 않은 경우 주저하지 말고 프로젝트 리드에게 추가 입력을 요청하십시오.

<a id="s3-version"></a>

## 3 C++ 버전

현재 코드는 C++17을 대상으로 해야 합니다.
즉, 지정된 이니셜라이저를 제외하고 C++2x 기능을 사용하면 안 됩니다.
이 가이드에서 대상으로 하는 C++ 버전은 시간이 지남에 따라 (공격적으로) 발전할 것입니다.
비표준 확장을 사용하지 마십시오.

프로젝트에서 C++14 및 C++17의 기능을 사용하기 전에 다른 환경으로의 이식성을 고려하십시오.

<a id="s4-header-files"></a>

## 4 헤더 파일

기본적으로 모든 `.cc` 파일은 수반된 `.h` 파일을 가져야 합니다. 흔한 예외로는 유닛 테스트나 `main()` 함수만을 가진 작은 `.cc` 파일 등이 있습니다.
헤더 파일을 바르게 사용하는 것으로 코드의 가독성과 크기와 성능에 큰 차이를 만들 수 있습니다.

아래 규칙들은 헤더 파일을 사용할 때 피해야 할 함정들에 관한 가이드입니다.

<a id="s4-1-self-contained-headers"></a>

### 4.1 독립적인 헤더

헤더 파일은 독립적이어야 하며(자체적으로 컴파일) .h로 끝나야 합니다. 포함할 헤더가 아닌 파일은 .inc로 끝나야 하며 드물게 사용해야 합니다.

모든 헤더 파일은 독립적이어야 합니다. 사용자와 리팩토링 도구는 헤더를 포함하기 위해 특별한 조건을 준수할 필요가 없습니다. 특히 헤더에는 헤더 가드가 있어야 하며 필요한 다른 모든 헤더를 포함해야 합니다.

헤더가 클라이언트가 인스턴스화 할 인라인 함수 또는 템플릿을 선언하는 경우 인라인 함수 및 템플릿도 헤더에 직접 또는 포함된 파일에 정의가 있어야 합니다.
이러한 정의를 별도로 포함된 헤더(-inl.h) 파일로 이동하지 마십시오. 이 관행은 과거에 일반적이었지만 더 이상 허용되지 않습니다.
템플릿의 모든 인스턴스화가 명시적이거나 .cc 파일에서만 정의에 액세스할 수 있기 때문에 하나의 .cc 파일에서 발생하는 경우 템플릿 정의를 해당 파일에 보관할 수 있습니다.

<a id="s4-2-the-define-guard"></a>

### 4.2 #define 가드

든 헤더 파일은 여러 번 포함되지 않기 위해 #define 가드를 사용해야 합니다. 기호의 포맷은 <PROJECT>_<PATH>_<FILE>_H_ 으로 합니다.

유일성을 보장하기 위해 #define 가드는 프로젝트의 소스 트리의 절대 경로에 기반해야 합니다. 예를 들어 프로젝트에 foo/src/bar/baz.h 파일이 있다면 foo는 아래와 같은 가드를 가져야 합니다.

```cpp
#ifndef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_

...

#endif  // FOO_BAR_BAZ_H_
```

<a id="include-what-you-use"></a>

### 4.3 include

소스 또는 헤더 파일이 다른 곳에서 정의된 기호를 참조하는 경우 파일에는 해당 기호의 선언 또는 정의를 적절하게 제공하려는 헤더 파일이 직접 포함되어야 합니다.
다른 이유로 헤더 파일을 포함하면 안 됩니다.

전이적 포함에 의존하지 마십시오. 이를 통해 사람들은 더 이상 필요하지 않은 #include 문을 클라이언트를 손상시키지 않고 헤더에서 제거할 수 있습니다. 이것은 관련 헤더에도 적용됩니다. foo.cc는
bar.h를 포함하더라도 foo.cc의 기호를 사용하는 경우 bar.h를 포함해야 합니다.

<a id="s4-4-forward-declarations"></a>

### 4.4 정방향 선언

가능하면 정방향 선언을 사용하지 마십시오. 대신 필요한 헤더를 포함하십시오.

정의:
"정방향 선언"이란 수반되는 정의 없이 클래스나 함수, 템플릿을 선언하는 것입니다.

```cpp
// In a C++ source file:
class B;
void FuncInB();
extern int variable_in_b;
ABSL_DECLARE_FLAG(flag_in_b);
```

장점:

- 불필요한 #include는 컴파일러가 더 많은 파일을 열고 더 많은 입력을 처리하도록 만듭니다.
- 불필요한 #include는 헤더 파일 변경 시 코드를 더 자주 다시 컴파일하도록 만듭니다.

단점:

- 정방향 선언은 종속성을 숨길 수 있으므로 헤더가 변경될 때 사용자 코드가 필요한 재컴파일을 건너뛸 수 있습니다.
- #include 문과 반대되는 전방 선언은 자동 도구가 기호를 정의하는 모듈을 검색하기 어렵게 만듭니다.
- 라이브러리에 대한 후속 변경으로 인해 손상될 수 있습니다.
  함수 및 템플릿의 전방향 선언은 API에 호환 가능한 변경을 수행하지 못하도록 할 수 있습니다.
- std:: 네임스페이스의 기호를 전방 선언하면 보통 예상할 수 없는 결과를 유발합니다.
- 전방 선언이 필요한지 전체 #include가 필요한지 판단하기 어려울 수 있습니다.
  #include를 정방향 선언으로 바꾸면 코드의 의미가 자동으로 변경될 수 있습니다.
  ```cpp
  // b.h:
  struct B {};
  struct D : B {};
  
  // good_user.cc:
  #include "b.h"
  void f(B*);
  void f(void*);
  void test(D* x) { f(x); }  // Calls f(B*)
  ```
  #include가 B 및 D에 대한 정방향 선언으로 대체된 경우 test()는 f(void*)를 호출합니다.
- 헤더에서 여러 기호를 앞에 선언하는 것은 단순히 헤더를 #include하는 것보다 더 장황할 수 있습니다.
- 코드가 더 느리고 복잡해질 수 있습니다.

결론:  
다른 프로젝트에 정의된 엔터티의 전방 선언을 피하십시오.

<a id="s4-5-inline-functions"></a>

### 4.5 인라인 함수

함수가 작은 경우에만 인라인으로 정의하십시오(예: 10줄 이하).

정의:  
컴파일러가 일반적인 함수 호출 메커니즘을 통해 함수를 호출하는 대신 인라인으로 확장할 수 있는 방식으로 함수를 선언할 수 있습니다.

장점:  
인라인된 함수가 작은 한 더 효율적인 개체 코드를 생성할 수 있습니다.
액세서와 뮤테이터, 기타 짧고 성능에 중요한 기능을 자유롭게 인라인하십시오.

단점:  
인라인을 과도하게 사용하면 실제로 프로그램이 느려질 수 있습니다.
함수의 크기에 따라 인라인하면 코드 크기가 늘어나거나 줄어들 수 있습니다.
매우 작은 접근자 함수를 인라인하면 일반적으로 코드 크기가 줄어들고 매우 큰 함수를 인라인하면 코드 크기가 크게 증가할 수 있습니다.
최신 프로세서에서 더 작은 코드는 일반적으로 명령어 캐시를 더 잘 사용하기 때문에 더 빠르게 실행됩니다.

결론:  
적절한 경험 법칙은 길이가 10줄 이상인 함수를 인라인하지 않는 것입니다.
암시적 멤버 및 기본 소멸자 호출로 인해 표시되는 것보다 더 긴 소멸자를 주의하십시오!

또 다른 유용한 경험 법칙: 일반적으로 루프 또는 스위치 문이 있는 인라인 함수는 비용 효율적이지 않습니다(일반적인 경우 루프 또는 스위치 문이 실행되지 않는 경우 제외).

함수가 그렇게 선언되더라도 항상 인라인되는 것은 아니라는 점을 아는 것이 중요합니다.
예를 들어 가상 및 재귀 함수는 일반적으로 인라인되지 않습니다. 일반적으로 재귀 함수는 인라인이어서는 안 됩니다. 가상 함수를 인라인으로 만드는 주된 이유는 편의를 위해 또는 액세서 및 뮤테이터에 대한 동작을
문서화하기 위해 클래스에 정의를 배치하는 것입니다.

<a id="s4-6-names-and-order-of-includes"></a>

### 4.6 포함 이름 및 순서

관련 헤더, C 시스템 헤더, C++ 표준 라이브러리 헤더, 기타 라이브러리 헤더, 프로젝트 헤더 순서로 헤더를 포함합니다.

프로젝트의 모든 헤더 파일은 UNIX 디렉토리 별칭 (현재 디렉토리) `.` 또는 `..` (상위 디렉토리)를 사용하지 않고 프로젝트 소스 디렉토리의 하위 항목으로 나열되어야 합니다
예를 들어 google-awesome-project/src/base/logging.h는 다음과 같이 포함되어야 합니다.

```cpp
#include "base/logging.h"
```

주된 목적이 dir2/foo2.h에 있는 것들을 구현하거나 테스트하기 위한 `dir/foo.cc`나 `dir/foo_test.cc`에서 include를 아래처럼 순서에 따라 배열하십시오.

1. dir2/foo2.h (아래 설명 참조).
2. C 시스템 파일
3. C++ 시스템 파일
4. 다른 라이브러리의 .h 파일
5. 현재 프로젝트의 .h 파일

이 순서에 따르면 `dir2/foo2.h`가 어느 필요한 include들을 빠뜨린 경우에 `dir/foo.cc`나 `dir/foo_test.cc`의 빌드는 망가집니다.
그러므로 이 규칙은 다른 패키지에서 작업하는 무고한 사람들의 빌드 실패보다 이 파일에서 작업하는 사람들의 빌드 실패를 먼저 보여주도록 합니다.

dir/foo.cc와 dir2/foo2.h는 종종 같은 디렉터리에 있지만, 다른 디렉터리에 있을 수 있습니다.
(예: base/basictypes_test.cc와 base/basictypes.h).

각각의 부분 안에서 include는 알파벳 순서로 나열되어야 합니다.
이전 코드는 이 규칙을 따르지 않을 수 있으므로 편리할 때 수정해야 합니다.

예를 들면 `google-awesome-project/src/foo/internal/fooserver.cc`의 include들은 다음과 같습니다.

```cpp
#include "foo/server/fooserver.h" 

#include <sys/types.h> 
#include <unistd.h> 

#include <문자열 
> #include <벡터> 

#include "base/basictypes.h" 
#include "foo /server/bar.h" 
#include "제3자/absl/flags/flag.h"
```

예외:  
경우에 따라 시스템별 코드에 조건부 포함이 필요합니다.
이러한 코드는 다른 포함 뒤에 조건부 포함을 넣을 수 있습니다. 물론 시스템별 코드를 작고 현지화하십시오

```cpp
#include "foo/public/fooserver.h" 

#include "base/port.h" // LANG_CXX11의 경우. 

#ifdef LANG_CXX11 
#include <initializer_list> 
#endif // LANG_CXX11
```

<a id="s5-scoping"></a>

## 5 범위 지정

<a id="s5-1-namespaces"></a>

### 5.1 네임스페이스

몇 가지 예외를 제외하고 네임스페이스에 코드를 배치합니다.

- 네임스페이스는 프로젝트 이름 및 해당 경로를 기반으로 고유한 이름을 가져야 합니다.
- using 지시문 (예: using namespace foo)을 사용하지 마십시오.
- 인라인 네임스페이스를 사용하지 마십시오.
- [명명되지 않은 네임스페이스에 대해서는 내부](https://google.github.io/styleguide/cppguide.html#Internal_Linkage)를 참조하십시오 .

정의:
네임스페이스는 전역 범위를 별개의 명명된 범위로 세분화하므로 전역 범위에서 이름 충돌을 방지하는 데 유용합니다.

장점:  
네임스페이스는 대규모 프로그램에서 이름 충돌을 방지하는 방법을 제공하는 동시에 대부분의 코드에서 합리적으로 짧은 이름을 사용할 수 있도록 합니다.

예를 들어 두 개의 서로 다른 프로젝트에 전역 범위에 Foo 클래스가 있는 경우
이러한 기호는 컴파일 시간이나 런타임에 충돌할 수 있습니다.
각 프로젝트가 자신의 코드를 네임스페이스에 배치하면 `project1::Foo` 및 `project2::Foo`는 이제 충돌하지 않는 별개의 기호이며
각 프로젝트의 네임스페이스 내의 코드는 접두사 없이 Foo를 계속 참조할 수 있습니다

인라인 네임스페이스는 해당 이름을 둘러싸는 범위에 자동으로 배치합니다. 예를 들어 다음 스니펫을 고려하십시오.

```cpp
namespace outer {
inline namespace inner {
  void foo();
}  // namespace inner
}  // namespace outer
```

`outer::inner::foo()` 및 `outer::foo()` 표현식은 상호 교환 가능합니다.
인라인 네임스페이스는 주로 버전 간 ABI 호환성을 위한 것입니다.

단점:  
네임스페이스는 이름이 참조하는 정의를 파악하는 메커니즘을 복잡하게 만들기 때문에 혼란스러울 수 있습니다.

특히 인라인 네임스페이스는 이름이 실제로 선언된 네임스페이스로 제한되지 않기 때문에 혼란스러울 수 있습니다.
일부 더 큰 버전 관리 정책의 일부로만 유용합니다.

일부 컨텍스트에서는 정규화된 이름으로 기호를 반복적으로 참조해야 합니다.
깊게 중첩된 네임스페이스의 경우 이로 인해 많은 혼란이 추가될 수 있습니다.

결론:  
네임스페이스는 다음과 같이 사용해야 합니다.

- [네임스페이스 이름 규칙](https://google.github.io/styleguide/cppguide.html#Namespace_Names)을 떠르십시오
- 주어진 예제에 표시된 대로 주석으로 여러 줄 이름 공간을 종료합니다.
- [gflags](https://gflags.github.io/gflags/) 정의/선언 및 다른 네임스페이스의 클래스 전방 선언 후에 전체 소스 파일을 래핑합니다.
  ```cpp
  // .h 파일 
  namespace mynamespace {
  
  // 모든 선언은 네임스페이스 범위 내에 있습니다.
  // 들여쓰기가 부족함을 알 수 있습니다.
  class MyClass {
  public:
  ...
  void Foo();
  };
  
  }
  ```
  ```cpp
  // .cc 파일 
  namespace mynamespace {
  
  // 함수 정의는 네임스페이스 범위 내에 있습니다.
  void MyClass::Foo() {
  ...
  }
  
  }
  ```
  ```cpp
  #include "a.h" 

  ABSL_FLAG(bool, someflag, false, "플래그");
  
  namespace mynamespace {
  
  using ::foo::Bar;
  
  ...code for mynamespace... // 코드는 왼쪽 여백에 반대합니다.
  
  }
  ```
- 생성된 프로토콜 메시지 코드를 네임스페이스에 배치하려면 파일 package에서 지정자를 사용하십시오
- std표준 라이브러리 클래스의 정방향 선언을 포함하여 namespace에 아무 것도 선언하지 마십시오.
  네임스페이스 std에서 엔터티를 선언하는 것은 정의되지 않은 동작입니다.
  즉, 이식할 수 없습니다. 표준 라이브러리에서 엔터티를 선언하려면 적절한 헤더 파일을 포함합니다.
- 사용 가능한 네임스페이스의 모든 이름을 만들기 위해 using 지시문을 사용할 수 없습니다 .
  ```cpp
  // Forbidden -- This pollutes the namespace.
  using namespace foo;
  ```
- 명시적으로 표시된 내부 전용 네임스페이스를 제외하고 헤더 파일의 네임스페이스 범위에서 네임스페이스 별칭을 사용하지 마십시오.
  헤더 파일의 네임스페이스로 가져온 항목은 해당 파일에서 내보낸 공용 API의 일부가 되기 때문입니다.
  ```cpp
  namespace baz = ::foo::bar::baz; 
  ```
  ```cpp
  // Shorten access to some commonly used names (in a .h file).
  namespace librarian {
  namespace impl {  // Internal, not part of the API.
  namespace sidetable = ::pipeline_diagnostics::sidetable;
  }  // namespace impl
  
  inline void my_inline_function() {
  // namespace alias local to a function (or method).
  namespace baz = ::foo::bar::baz;
  ...
  }
  }  // namespace librarian
  ```
- 인라인 네임스페이스를 사용하지 마십시오.
- 이름에 "internal"이 포함된 네임스페이스를 사용하여 API 사용자가 언급해서는 안 되는 API 부분을 문서화합니다.
  ```cpp
  // We shouldn't use this internal name in non-absl code.
  using ::absl::container_internal::ImplementationDetail;
  ```

<a id="s5-2-internal-linkage"></a>

### 5.2 내부 연계

`.cc` 파일의 정의를 해당 파일 외부에서 참조할 필요가 없으면 명명되지 않은 네임스페이스에 배치하거나 정적으로 선언하여 내부 연결을 제공합니다.
`.h` 파일에서 이러한 구문 중 하나를 사용하지 마십시오.

정의:  
모든 선언은 명명되지 않은 네임스페이스에 배치하여 내부 연결을 제공할 수 있습니다.
함수와 변수는 정적으로 선언하여 내부 연결을 제공할 수도 있습니다.
즉, 선언하는 모든 항목은 다른 파일에서 액세스할 수 없습니다.
다른 파일이 동일한 이름을 가진 항목을 선언하면 두 엔터티는 완전히 독립적입니다.

결정:  
`.cc` 파일에서 내부 연결을 사용하는 것은 다른 곳에서 참조할 필요가 없는 모든 코드에 권장됩니다.
`.h` 파일에서 내부 연결을 사용하지 마십시오.

명명된 네임스페이스와 같이 명명되지 않은 네임스페이스를 포맷합니다. 종료 주석에서 네임스페이스 이름을 비워 둡니다.

```cpp
namespace {
...
}  // namespace
```

<a id="s5-3-nonmember-static-mamber-and-global-function"></a>

### 5.3 정적 멤버 및 전역 함수

네임스페이스에 비멤버 함수를 배치하는 것을 선호하며, 전역 함수를 거의 사용하지 않습니다.
단순히 정적 구성원을 그룹화하기 위해 클래스를 사용하지 마십시오.
클래스의 정적 메서드는 일반적으로 클래스의 인스턴스 또는 클래스의 정적 데이터와 밀접하게 관련되어야 합니다.

장점:  
비멤버 및 정적 멤버 함수는 일부 상황에서 유용할 수 있습니다.
네임스페이스에 비멤버 함수를 넣으면 전역 네임스페이스가 오염되는 것을 방지할 수 있습니다.

단점:  
비멤버 및 정적 멤버 함수는 특히 외부 리소스에 액세스하거나 상당한 종속성이 있는 경우 새 클래스의 멤버로 더 적합할 수 있습니다.

결정:  
때로는 클래스 인스턴스에 바인딩되지 않은 함수를 정의하는 것이 유용합니다.
이러한 함수는 정적 멤버이거나 비멤버 함수일 수 있습니다.
비멤버 함수는 외부 변수에 의존해서는 안 되며 거의 항상 네임스페이스에 있어야 합니다.
정적 구성원을 그룹화하기 위한 클래스만 만들지 마십시오.
이것은 이름에 공통 접두사를 부여하는 것과 다르지 않으며 이러한 그룹화는 일반적으로 필요하지 않습니다.

<a id="s5-4-local-variables"></a>

### 5.4 지역 변수

함수의 변수를 가능한 가장 좁은 범위에 배치하고 선언에서 변수를 초기화합니다.

C++에서는 함수의 어디에서나 변수를 선언할 수 있습니다.
가능한 한 로컬 범위로 선언하고 가능한 한 첫 번째 사용에 가깝게 선언하는 것이 좋습니다.
이렇게 하면 독자가 선언을 쉽게 찾고 변수의 유형과 초기화된 내용을 쉽게 확인할 수 있습니다.
특히 다음과 같이 선언 및 할당 대신 초기화를 사용해야 합니다.

```cpp
int i;
i = f();      // Bad -- initialization separate from declaration.
```

```cpp
int i = f();  // Good -- declaration has initialization.
```

```cpp
int jobs = NumJobs();
// More code...
f(jobs);      // Bad -- declaration separate from use.
```

```cpp
int jobs = NumJobs();
f(jobs);      // Good -- declaration immediately (or closely) followed by use.
```

```cpp
std::vector<int> v;
v.push_back(1);  // Prefer initializing using brace initialization.
v.push_back(2);
```

```cpp
std::vector<int> v = {1, 2};  // Good -- v starts initialized.
```

`if`, `while` 및 `for` 문에 필요한 변수는 일반적으로 해당 문 내에서 선언되어야 해당 변수가 해당 범위로 제한됩니다.

```cpp
while (const char* p = strchr(str, '/')) str = p + 1;
```

한 가지 주의할 점이 있습니다.
변수가 객체인 경우 변수가 범위에 들어가 생성될 때마다 생성자가 호출되고 범위를 벗어날 때마다 소멸자가 호출됩니다.

```cpp
// Inefficient implementation:
for (int i = 0; i < 1000000; ++i) {
  Foo f;  // My ctor and dtor get called 1000000 times each.
  f.DoSomething(i);
}
```

루프 외부의 루프에서 사용되는 변수를 선언하는 것이 더 효율적일 수 있습니다.

```cpp
Foo f;  // My ctor and dtor get called once each.
for (int i = 0; i < 1000000; ++i) {
  f.DoSomething(i);
}
```

<a id="s5-5-static-and-global-variables"></a>

### 5.5 전역 변수

정적 저장 기간이 있는 개체는 사소하게 파괴할 수 있는 경우가 아니면 금지됩니다.
비공식적으로 이것은 소멸자가 멤버 및 기본 소멸자를 고려하더라도 아무 작업도 수행하지 않음을 의미합니다.
보다 공식적으로는 형식에 사용자 정의 또는 가상 소멸자가 없으며 모든 기본 및 비정적 멤버가 사소하게 파괴될 수 있음을 의미합니다.
정적 함수 로컬 변수는 동적 초기화를 사용할 수 있습니다.
정적 클래스 멤버 변수 또는 네임스페이스 범위의 변수에 대한 동적 초기화 사용은 권장되지 않지만 제한된 상황에서 허용됩니다.
자세한 내용은 아래를 참조하십시오.

정의:  
모든 개체에는 수명과 상관 관계가 있는 저장 기간이 있습니다.
정적 저장 기간이 있는 개체는 초기화 시점부터 프로그램이 끝날 때까지 유지됩니다.
이러한 개체는 네임스페이스 범위의 변수("전역 변수"), 클래스의 정적 데이터 멤버 또는 정적 지정자로 선언된 함수 로컬 변수로 나타납니다.
함수 로컬 정적 변수는 컨트롤이 선언을 처음 통과할 때 초기화됩니다.
정적 저장 기간을 가진 다른 모든 개체는 프로그램 시작의 일부로 초기화됩니다.
정적 저장 기간이 있는 모든 객체는 프로그램 종료 시 소멸됩니다(조인되지 않은 스레드가 종료되기 전에 발생).

초기화는 동적일 수 있습니다.
즉, 초기화 중에 사소하지 않은 일이 발생합니다.
(예를 들어, 메모리를 할당하는 생성자 또는 현재 프로세스 ID로 초기화되는 변수를 고려하십시오.)
다른 종류의 초기화는 정적 초기화입니다. 그러나 두 가지가 완전히 반대되는 것은 아닙니다.
정적 초기화는 항상 정적 저장 기간이 있는 개체에 발생합니다(주어진 상수 또는 0으로 설정된 모든 바이트로 구성된 표현으로 개체 초기화).
반면 동적 초기화는 그 이후에 발생합니다.

장점:  
전역 및 정적 변수는 명명된 상수, 일부 변환 단위 내부의 보조 데이터 구조, 명령줄 플래그, 로깅, 등록 메커니즘, 백그라운드 인프라 등 많은 응용 프로그램에 매우 유용합니다.

단점:  
동적 초기화를 사용하거나 사소하지 않은 소멸자가 있는 전역 및 정적 변수는 찾기 어려운 버그로 쉽게 이어질 수 있는 복잡성을 생성합니다.
동적 초기화는 번역 단위 간에 순서가 지정되지 않으며 소멸도 아닙니다(초기화의 역순으로 소멸이 발생한다는 점 제외).
한 초기화가 정적 저장 기간이 있는 다른 변수를 참조하는 경우 수명이 시작되기 전에(또는 수명이 종료된 후) 개체에 액세스할 수 있습니다.
또한 프로그램이 종료 시 조인되지 않은 스레드를 시작할 때 소멸자가 이미 실행된 경우 해당 스레드는 수명이 종료된 후 개체에 액세스하려고 시도할 수 있습니다.

<a id="s5-5-1-decsion-on-destruction"></a>

#### 5.5.1 파기 결정

소멸자가 사소한 경우 실행은 순서에 전혀 영향을 받지 않습니다(효과적으로 "실행"되지 않음).
그렇지 않으면 수명이 다한 후에 개체에 액세스할 위험에 노출됩니다.
따라서 우리는 정적 저장 기간이 있는 객체만 사소하게 파괴할 수 있는 경우에만 허용합니다.
기본 유형(`포인터` 및 `int`와 같은)은 간단하게 파괴할 수 있는 유형의 배열과 마찬가지로 간단하게 파괴할 수 있습니다.
`constexpr`로 표시된 변수는 사소하게 파괴할 수 있습니다.

```cpp
const int kNum = 10;  // Allowed

struct X { int n; };
const X kX[] = {{1}, {2}, {3}};  // Allowed

void foo() {
  static const char* const kMessages[] = {"hello", "world"};  // Allowed
}

// Allowed: constexpr guarantees trivial destructor.
constexpr std::array<int, 3> kArray = {1, 2, 3};
```

```cpp
// bad: non-trivial destructor
const std::string kFoo = "foo";

// Bad for the same reason, even though kBar is a reference (the
// rule also applies to lifetime-extended temporary objects).
const std::string& kBar = StrCat("a", "b", "c");

void bar() {
  // Bad: non-trivial destructor.
  static std::map<int, int> kData = {{1, 0}, {2, 0}, {3, 0}};
}
```

<a id="s5-5-2-decsion-on-initialization"></a>

#### 5.5.2 초기화 결정

초기화는 보다 복잡한 주제입니다. 이는 클래스 생성자의 실행 여부를 고려해야 할 뿐만 아니라 초기화 프로그램의 평가도 고려해야 하기 때문입니다.

```cpp
int n = 5;    // Fine
int m = f();  // ? (Depends on f)
Foo x;        // ? (Depends on Foo::Foo)
Bar y = g();  // ? (Depends on g and on Bar::Bar)
```

첫 번째 문을 제외한 모든 문은 불확실한 초기화 순서에 노출됩니다.

우리가 찾고 있는 개념은 C++ 표준의 공식 언어에서 상수 초기화라고 합니다.
이는 초기화 표현식이 상수 표현식임을 의미하며 객체가 생성자 호출에 의해 초기화되면 생성자도 `constexpr`로 지정되어야 합니다.

```cpp
struct Foo { constexpr Foo(int) {} };

int n = 5;  // Fine, 5 is a constant expression.
Foo x(2);   // Fine, 2 is a constant expression and the chosen constructor is constexpr.
Foo a[] = { Foo(1), Foo(2), Foo(3) };  // Fine
```

상수 초기화는 항상 허용됩니다. 정적 저장 기간 변수의 지속적인 초기화는 `constexpr` 또는 가능한 경우 `ABSL_CONST_INIT` 속성으로 표시되어야 합니다.
그렇게 표시되지 않은 로컬이 아닌 정적 저장 기간 변수는 동적 초기화가 있는 것으로 가정하고 매우 신중하게 검토해야 합니다.

반대로 다음 초기화는 문제가 있습니다.

```cpp
// Some declarations used below.
time_t time(time_t*);      // Not constexpr!
int f();                   // Not constexpr!
struct Bar { Bar() {} };

// Problematic initializations.
time_t m = time(nullptr);  // Initializing expression not a constant expression.
Foo y(f());                // Ditto
Bar b;                     // Chosen constructor Bar::Bar() not constexpr.
```

비지역 변수의 동적 초기화는 권장되지 않으며 일반적으로 금지됩니다.
그러나 프로그램의 어떤 측면도 다른 모든 초기화와 관련하여 이 초기화의 순서에 의존하지 않는 경우 허용합니다.
이러한 제한 사항에 따라 초기화 순서는 눈에 띄는 차이를 만들지 않습니다.

```cpp
int p = getpid();  // Allowed, as long as no other static variable
                   // uses p in its own initialization.
```

정적 지역 변수의 동적 초기화가 허용됩니다(일반적임).

<a id="s5-6-thread-local-variables"></a>

### 5.6 thread_local 변수

함수 내에서 선언되지 않은 변수는 진정한 컴파일 타임 상수로 초기화되어야 하며 이는 특성을 사용하여 적용되어야 합니다.
스레드 로컬 데이터를 정의하는 다른 방법보다 우선합니다.

정의:  
변수는 지정자를 사용하여 선언할 수 있습니다.

```cpp
thread_local Foo foo = ...;
```

이러한 변수는 실제로 개체의 모음이므로 다른 스레드가 액세스할 때 실제로는 다른 개체에 액세스합니다.
변수는 여러 측면에서 [정적 저장 기간 변수](https://google.github.io/styleguide/cppguide.html#Static_and_Global_Variables)와thread_local 매우
유사합니다.
예를 들어 네임스페이스 범위, 함수 내부 또는 정적 클래스 멤버로 선언할 수 있지만 일반 클래스 멤버로는 선언할 수 없습니다.

변수 인스턴스는 프로그램 시작 시 한 번이 아니라 각 스레드에 대해 개별적으로 초기화해야 한다는 점을 제외하면
정적 변수와 매우 유사하게 초기화됩니다.
즉, 함수 내에서 선언된 변수는 안전하지만 다른 변수는 정적 변수(및 기타)와 동일한 초기화 순서 문제가 적용됩니다.

thread_local 변수 인스턴스는 스레드가 종료되기 전에 소멸되지 않으므로 정적 변수의 소멸 순서 문제가 없습니다.

장점:

- 스레드 로컬 데이터는 본질적으로 레이스로부터 안전하며(일반적으로 하나의 스레드만 데이터에 액세스할 수 있기 때문에) 병렬 프로그래밍에 유용합니다.
- 스레드 로컬 데이터를 생성하는 유일한 표준 지원 방법입니다.

단점:

- 예측할 수 없고 제어할 수 없는 다른 코드가 실행될 수 있습니다.
- 사실상 전역 변수이며 스레드 안전성이 부족한 것 외에 전역 변수의 모든 단점이 있습니다.
- 변수가 사용하는 메모리는 실행 중인 스레드 수(최악의 경우)에 따라 확장되며 프로그램에서 상당히 클 수 있습니다.
- 비정적 데이터 멤버가 될 수 없습니다
- 특정 컴파일러 내장 함수만큼 효율적이지 않을 수 있습니다.

함수 내부의 thread_local 변수는 안전 문제가 없으므로 제한 없이 사용할 수 있습니다.
함수 범위 thread_local을 사용하여 이를 노출하는 함수 또는 정적 메서드를 정의하여 클래스 또는 네임스페이스 범위 thread_local을 시뮬레이트할 수 있습니다.

```cpp
Foo& MyThreadLocalFoo() {
  thread_local Foo result = ComplicatedInitialization();
  return result;
}
```

클래스 또는 네임스페이스 범위의 thread_local 변수는 진정한 컴파일 타임 상수로 초기화되어야 합니다(즉, 동적 초기화가 없어야 함).
이를 적용하려면 클래스 또는 네임스페이스 범위의 thread_local
변수에 [ABSL_CONST_INIT](https://github.com/abseil/abseil-cpp/blob/master/absl/base/attributes.h)(또는 constexpr, 드물지만)로 주석을
달아야 합니다.

```cpp
ABSL_CONST_INIT thread_local Foo foo = ...;
```

<a id="s6-class"></a>

## 6 클래스

클래스는 C++ 코드의 기본 단위입니다. 당연히 우리는 그것들을 광범위하게 사용합니다.
이 섹션에는 클래스를 작성할 때 따라야 할 주요 사항과 하지 말아야 할 사항이 나열되어 있습니다.

<a id="s6-1-doing-work-in-constructors-declaration-order"></a>

### 6.1 생성자에서 작업하기

생성자에서 가상 메소드 호출을 피하고 오류 신호를 보낼 수 없는 경우 실패할 수 있는 초기화를 피하십시오.

정의:  
생성자 본체에서 임의의 초기화를 수행할 수 있습니다.

장점:

- 클래스가 초기화되었는지 여부에 대해 걱정할 필요가 없습니다.
- 생성자 호출에 의해 완전히 초기화된 객체는 `const` 표준 컨테이너 또는 알고리즘과 함께 사용하는 것이 더 쉬울 수 있습니다.

단점:

- 작업이 가상 함수를 호출하는 경우 이러한 호출은 하위 클래스 구현으로 디스패치되지 않습니다.
  클래스에 대한 향후 수정은 클래스가 현재 하위 클래스가 아니더라도 이 문제를 조용히 도입하여 많은 혼란을 야기할 수 있습니다.
- 프로그램 충돌(항상 적절한 것은 아님) 또는 예외 사용(금지됨)이 아니면 생성자가 오류를 알리는 쉬운 방법이 없습니다.
- 작업이 실패하면 이제 초기화 코드가 실패한 개체가 있으므로 `bool IsValid()`호출하는 것을 잊기 쉬운 상태 확인 메커니즘(또는 유사)이 필요한 비정상적인 상태일 수 있습니다.
- 생성자의 주소를 가져올 수 없으므로 생성자에서 수행되는 모든 작업을 예를 들어 다른 스레드에 쉽게 전달할 수 없습니다.

결론:  
생성자는 가상 함수를 호출하면 안 됩니다.
코드에 적합한 경우 프로그램을 종료하는 것이 적절한 오류 처리 응답일 수 있습니다.

<a id="s6-2-implicit-conversions"></a>

### 6.2 암시적 변환

암시적 변환을 정의하지 마십시오.
explicit 변환 연산자 및 단일 인수 생성자에 키워드를 사용하십시오

정의:  
암시적 변환을 사용하면 매개 변수를 사용하는 함수에 인수를 전달할 때와 같이 다른 유형(`대상 유형`)이 예상되는 경우 한 유형(`소스 유형`)의 개체를 사용할 수 있습니다.

언어로 정의된 암시적 변환 외에도 사용자는 소스 또는 대상 유형의 클래스 정의에 적절한 멤버를 추가하여 고유한 변환을 정의할 수 있습니다.   
`소스 유형`의 암시적 변환은 대상 유형(예: operator bool())의 이름을 따서 명명된 유형 변환 연산자에 의해 정의됩니다.   
`대상 유형`의 암시적 변환은 소스 유형을 유일한 인수(또는 기본값이 없는 유일한 인수)로 사용할 수 있는 생성자에 의해 정의됩니다.

키워드 explicit는 생성자나 변환 연산자에 적용하여 대상 유형이 사용 시점에서 명시적일 때만 사용할 수 있도록 할 수 있습니다(예: 캐스트 포함).
이는 암시적 변환뿐만 아니라 목록 초기화 구문에도 적용됩니다.

```cpp
class Foo {
  explicit Foo(int x, double y);
  ...
};

void Func(Foo f);
```

```cpp
Func({42, 3.14});  // Error
```

이러한 종류의 코드는 기술적으로 암시적 변환이 아니지만 언어에서는 이를 명시적 변환으로 취급합니다.

장점:

- 암시적 변환은 유형이 분명한 경우 명시적으로 이름을 지정하지 않아도 되므로 유용하고 표현력 있게 만들 수 있습니다.
- 암시적 변환은 매개 변수가 있는 단일 함수가 및 string_view에 대한 별도의 오버로드를 대신하는 경우와 같이 오버로드에 대한 더 간단한 대안이 될 수 있습니다.
  ```cpp
  std::stringconst char*
  ```
- 목록 초기화 구문은 개체를 초기화하는 간결하고 표현적인 방법입니다.

단점:

- 암시적 변환은 대상 유형이 사용자의 기대와 일치하지 않거나 사용자가 어떤 변환이 발생하는지 알지 못하는 유형 불일치 버그를 숨길 수 있습니다.
- 암시적 변환은 실제로 어떤 코드가 호출되는지 명확하지 않게 함으로써 특히 오버로드가 있는 경우 코드를 읽기 어렵게 만들 수 있습니다.
- 단일 인수를 사용하는 생성자는 의도하지 않은 경우에도 실수로 암시적 형식 변환으로 사용할 수 있습니다.
- 단일 인수 생성자가 표시되지 않은 경우 explicit암시적 변환을 정의하려는 것인지 아니면 작성자가 단순히 표시하는 것을 잊었는지 알 수 있는 신뢰할 수 있는 방법이 없습니다.
- 암시적 변환은 특히 양방향 암시적 변환이 있는 경우 호출 사이트 모호성을 유발할 수 있습니다. 이는 암시적 변환을 제공하는 두 가지 형식이 있거나 암시적 생성자와 암시적 형식 변환 연산자가 모두 있는 단일
  형식으로 인해 발생할 수 있습니다.
- 목록 초기화는 대상 유형이 암시적일 경우, 특히 목록에 단일 요소만 있는 경우 동일한 문제가 발생할 수 있습니다.

결론:  
유형 변환 연산자 및 단일 인수로 호출할 수 있는 생성자는 `explicit` 클래스 정의에 표시되어야 합니다.
예외적으로 복사 및 이동 생성자는 `explicit` 형식 변환을 수행하지 않으므로 가 아니어야 합니다.

예를 들어 두 형식의 개체가 동일한 기본 값의 다른 표현인 경우와 같이 상호 교환 가능하도록 설계된 형식에 암시적 변환이 필요하고 적절할 수 있습니다.
이 경우 프로젝트 리드에게 연락하여 이 규칙의 면제를 요청하십시오.

단일 인수로 호출할 수 없는 생성자는 생략할 수 있습니다.

<a id="s6-3-copyable-and-movable-types"></a>

### 6.3 복사 가능 및 이동 가능 유형

클래스의 공용 API는 클래스가 복사 가능한지, 이동만 가능한지 또는 복사 및 이동이 불가능한지 명확히 해야 합니다.
이러한 작업이 유형에 대해 명확하고 의미 있는 경우 복사 및/또는 이동을 지원합니다.

정의:  
이동 가능한 유형은 초기화되고 임시에서 할당될 수 있는 유형입니다.

복사 가능한 유형은 소스 값이 변경되지 않는다는 조건 하에 동일한 유형의 다른 개체에서 초기화하거나 할당할 수 있는 유형입니다(정의에 따라 이동할 수도 있음).
std::unique_ptr<int>는 이동할 수 있지만 복사할 수 없는 유형의 예입니다(소스 std::unique_ptr<int>의 값은 대상에 할당하는 동안 수정해야 하므로).
int 및 std::string은 복사할 수도 있는 이동 가능한 유형의 예입니다. (int의 경우 이동과 복사 작업이 동일하고 std::string의 경우 복사보다 비용이 덜 드는 이동 작업이 존재합니다.)

사용자 정의 형식의 경우 복사 동작은 복사 생성자와 복사 할당 연산자에 의해 정의됩니다.
이동 동작은 이동 생성자와 이동 할당 연산자(존재하는 경우)에 의해 정의되고, 그렇지 않은 경우 복사 생성자와 복사 할당 연산자에 의해 정의됩니다.

복사/이동 생성자는 일부 상황(예: 개체를 값으로 전달할 때)에서 컴파일러에 의해 암시적으로 호출될 수 있습니다.

장점:  
복사 가능 및 이동 가능 유형의 객체는 값으로 전달 및 반환될 수 있으므로 API가 더 간단하고 안전하며 더 일반적입니다.
포인터나 참조로 개체를 전달할 때와 달리 소유권, 수명, 변경 가능성 및 유사한 문제에 대한 혼동의 위험이 없으며 계약에서 지정할 필요가 없습니다.
또한 클라이언트와 구현 간의 로컬이 아닌 상호 작용을 방지하여 컴파일러에서 이해, 유지 관리 및 최적화를 더 쉽게 만듭니다.
또한 이러한 개체는 대부분의 컨테이너와 같이 값에 의한 전달이 필요한 일반 API와 함께 사용할 수 있으며 유형 구성과 같은 추가 유연성을 허용합니다.

단점:  
일부 유형은 복사 가능할 필요가 없으며 이러한 유형에 대한 복사 작업을 제공하는 것은 혼란스럽거나 무의미하거나 완전히 올바르지 않을 수 있습니다.
싱글톤 개체(Registerer), 특정 범위에 연결된 개체(정리) 또는 개체 ID와 밀접하게 결합된 개체(Mutex)를 나타내는 형식은 의미 있게 복사할 수 없습니다.
다형적으로 사용될 기본 클래스 유형에 대한 복사 작업은 위험합니다. 복사 작업을 사용하면 개체 분할이 발생할 수 있기 때문입니다.
기본 설정되거나 부주의하게 구현된 복사 작업은 올바르지 않을 수 있으며 그로 인해 발생하는 버그는 혼란스럽고 진단하기 어려울 수 있습니다.

복사 생성자는 암시적으로 호출되므로 호출을 놓치기 쉽습니다.
이것은 pass-by-reference가 관례적이거나 의무적인 언어에 익숙한 프로그래머에게 혼란을 줄 수 있습니다.
또한 과도한 복사를 조장하여 성능 문제를 일으킬 수 있습니다.

결론:  
모든 클래스의 공용 인터페이스는 클래스가 지원하는 복사 및 이동 작업을 명확히 해야 합니다.
이는 일반적으로 선언의 공개 섹션에서 적절한 작업을 명시적으로 선언 및/또는 삭제하는 형식을 취해야 합니다.

특히, 복사 가능한 클래스는 복사 작업을

- 명시적으로 선언해야 하고,
- 이동 전용 클래스는 이동 작업을 명시적으로 선언해야 하며,
- 복사 불가능/이동 가능 클래스는 복사 작업을 명시적으로 삭제해야 합니다.

복사 가능한 클래스는 효율적인 이동을 지원하기 위해 이동 작업을 선언할 수도 있습니다.
복사/이동 작업을 모두 명시적으로 선언하거나 삭제할 수 있지만 필수는 아닙니다.
복사 또는 이동 할당 연산자를 제공하는 경우 해당 생성자도 제공해야 합니다.

```cpp
class Copyable {
 public:
  Copyable(const Copyable& other) = default;
  Copyable& operator=(const Copyable& other) = default;

  // The implicit move operations are suppressed by the declarations above.
  // You may explicitly declare move operations to support efficient moves.
};

class MoveOnly {
 public:
  MoveOnly(MoveOnly&& other) = default;
  MoveOnly& operator=(MoveOnly&& other) = default;

  // The copy operations are implicitly deleted, but you can
  // spell that out explicitly if you want:
  MoveOnly(const MoveOnly&) = delete;
  MoveOnly& operator=(const MoveOnly&) = delete;
};

class NotCopyableOrMovable {
 public:
  // Not copyable or movable
  NotCopyableOrMovable(const NotCopyableOrMovable&) = delete;
  NotCopyableOrMovable& operator=(const NotCopyableOrMovable&)
      = delete;

  // The move operations are implicitly disabled, but you can
  // spell that out explicitly if you want:
  NotCopyableOrMovable(NotCopyableOrMovable&&) = delete;
  NotCopyableOrMovable& operator=(NotCopyableOrMovable&&)
      = delete;
```

이러한 선언/삭제는 분명한 경우에만 생략할 수 있습니다.

- 클래스에 구조체 또는 인터페이스 전용 기본 클래스와 같은 전용 섹션이 없는 경우 복사 가능성/이동 가능성은 공용 데이터 멤버의 복사 가능성/이동 가능성에 의해 결정될 수 있습니다.
- 기본 클래스가 명확하게 복사 또는 이동이 불가능한 경우 파생 클래스도 마찬가지입니다.
  이러한 작업을 암시적으로 남겨두는 인터페이스 전용 기본 클래스는 구체적인 하위 클래스를 명확하게 만드는 데 충분하지 않습니다.
- 복사에 대한 생성자 또는 대입 연산 중 하나를 명시적으로 선언하거나 삭제하면 다른 복사 연산은 명확하지 않으며 선언하거나 삭제해야 합니다.
  이동 작업도 마찬가지입니다.

일반 사용자에게 복사/이동의 의미가 명확하지 않거나 예기치 않은 비용이 발생하는 경우 유형은 복사/이동할 수 없어야 합니다.
복사 가능한 유형에 대한 이동 작업은 엄격하게 성능 최적화이며 버그 및 복잡성의 잠재적인 원인이므로 해당 복사 작업보다 훨씬 더 효율적이지 않은 경우 정의하지 마십시오.
유형이 복사 작업을 제공하는 경우 이러한 작업의 기본 구현이 올바르도록 클래스를 설계하는 것이 좋습니다.
다른 코드와 마찬가지로 기본 작업의 정확성을 검토해야 합니다.

슬라이싱의 위험을 제거하려면 생성자를 보호하거나 소멸자를 보호한다고 선언하거나 하나 이상의 순수 가상 멤버 함수를 제공하여 기본 클래스를 추상화하는 것이 좋습니다.
구체적인 클래스에서 파생되는 것을 피하는 것이 좋습니다.

<a id="s6-4-structs-vs-classes"></a>

### 6.4 구조체 vs 클래스

데이터를 전달하는 패시브 객체에만 구조체를 사용하십시오. 다른 모든 것은 클래스입니다.

struct 및 class 키워드는 C++에서 거의 동일하게 작동합니다.
각 키워드에 고유한 의미론적 의미를 추가하므로 정의하는 데이터 유형에 적합한 키워드를 사용해야 합니다.

구조체는 데이터를 전달하는 수동 개체에 사용해야 하며 연결된 상수가 있을 수 있습니다.
모든 필드는 공개되어야 합니다.
구조체에는 서로 다른 필드 간의 관계를 암시하는 불변이 없어야 합니다.
해당 필드에 대한 사용자의 직접 액세스가 해당 불변을 깨뜨릴 수 있기 때문입니다.
생성자, 소멸자 및 도우미 메서드가 있을 수 있습니다. 그러나 이러한 방법은 불변성을 요구하거나 강제하지 않아야 합니다.

더 많은 기능이나 불변성이 필요한 경우 클래스가 더 적합합니다. 의심스러운 경우 클래스로 만드십시오.

STL과의 일관성을 위해 특성, 템플릿 메타 함수 및 일부 펑터와 같은 상태 비저장 유형에 클래스 대신 구조체를 사용할 수 있습니다.

구조체와 클래스의 멤버 변수에는 서로 다른 이름 지정 규칙이 있습니다.

<a id="s6-5-structs-vs-pairs-and-tuples"></a>

### 6.5 구조체 vs 쌍/튜플

요소가 의미 있는 이름을 가질 수 있을 때마다 쌍이나 튜플 대신 구조체를 사용하는 것이 좋습니다.

쌍과 튜플을 사용하면 사용자 정의 유형을 정의할 필요가 없어 코드를 작성할 때 잠재적으로 작업을 절약할 수 있지만 의미 있는 필드 이름은 `.first`, `.second` 또는 `std::get<X>`보다 코드를
읽을 때 훨씬 더 명확합니다.
인덱스가 아닌 유형별로 튜플 요소에 액세스하기 위한 C++14의 `std::get<Type>` 도입(유형이 고유한 경우)은 때때로 이를 부분적으로 완화할 수 있지만 일반적으로 필드 이름은 유형보다 상당히 명확하고 더
많은 정보를 제공합니다.

<a id="s6-6-inheritance"></a>

### 6.6 상속

종종 상속보다 구현이 더 적절합니다. 상속을 사용할 때는 공개하십시오.

정의:  
하위 클래스가 기본 클래스에서 상속되면 기본 클래스가 정의하는 모든 데이터 및 작업의 정의가 포함됩니다.
`인터페이스 상속`은 순수 추상 기본 클래스(상태 또는 정의된 메서드가 없는 클래스)로부터의 상속입니다.
다른 모든 상속은 `구현 상속`입니다.

장점:  
`구현 상속`은 기존 유형을 전문화할 때 기본 클래스 코드를 재사용하여 코드 크기를 줄입니다.
상속은 컴파일 타임 선언이므로 사용자와 컴파일러는 작업을 이해하고 오류를 감지할 수 있습니다.
`인터페이스 상속`을 사용하여 클래스가 특정 API를 노출하도록 프로그래밍 방식으로 적용할 수 있습니다.
다시 말하지만 컴파일러는 이 경우 클래스가 API의 필수 메서드를 정의하지 않는 경우 오류를 감지할 수 있습니다.

단점:  
`구현 상속`의 경우 하위 클래스를 구현하는 코드가 기본 클래스와 하위 클래스 사이에 분산되어 있으므로 구현을 이해하기가 더 어려울 수 있습니다.
하위 클래스는 가상이 아닌 함수를 재정의할 수 없으므로 하위 클래스는 구현을 변경할 수 없습니다.

`다중 상속`은 종종 더 높은 성능 오버헤드를 부과하기 때문에 특히 문제가 됩니다.

결론:  
모든 상속은 공개되어야 합니다.
비공개 상속을 하려면 대신 기본 클래스의 인스턴스를 멤버로 포함해야 합니다.
클래스를 기본 클래스로 사용하도록 지원하지 않으려는 경우 클래스에서 final을 사용할 수 있습니다.

`구현 상속`을 과도하게 사용하지 마십시오. 구현이 더 적절한 경우가 많습니다.
상속 사용을 "is-a" 경우로 제한하십시오.
(Bar가 Foo의 일종이라고 합리적으로 말할 수 있는 경우 Bar는 Foo를 하위 클래스로 분류합니다.)

하위 클래스에서 액세스해야 할 수 있는 멤버 함수로 보호 사용을 제한하십시오. 데이터 멤버는 비공개여야 합니다.

재정의 또는 (덜 자주) 최종 지정자 중 정확히 하나로 가상 함수 또는 가상 소멸자의 재정의에 명시적으로 주석을 추가합니다.   
재정의를 선언할 때 virtual을 사용하지 마십시오.
(근거: 기본 클래스 가상 함수의 재정의가 아닌 override 또는 final로 표시된 함수 또는 소멸자는 컴파일되지 않으며 이는 일반적인 오류를 잡는 데 도움이 됩니다.)

지정자는 문서로 사용됩니다. 지정자가 없으면 리더는 해당 클래스의 모든 조상을 확인하여 함수나 소멸자가 가상인지 여부를 확인해야 합니다.

`다중 상속`은 허용되지만 다중 구현 상속은 권장되지 않습니다.

<a id="s6-7-operator-overloading"></a>

### 6.7 오퍼레이터 오버로딩

연산자를 신중하게 오버로드합니다. 사용자 정의 리터럴을 사용하지 마십시오.

정의:  
C++에서는 매개 변수 중 하나가 사용자 정의 형식인 경우 사용자 코드에서 operator 키워드를 사용하여 기본 제공 연산자의 오버로드된 버전을 선언할 수 있습니다.
operator 키워드는 또한 사용자 코드가 operator""를 사용하여 새로운 종류의 리터럴을 정의하고 operator bool()과 같은 유형 변환 함수를 정의하도록 허용합니다.

장점:  
연산자 오버로딩은 사용자 정의 유형이 기본 제공 유형과 동일하게 작동하도록 하여 코드를 더 간결하고 직관적으로 만들 수 있습니다.
오버로드된 연산자는 특정 작업(예: ==, <, = 및 <<)에 대한 관용적 이름이며 이러한 규칙을 준수하면 사용자 정의 유형을 더 읽기 쉽게 만들고 해당 이름이 필요한 라이브러리와 상호 운용할 수 있습니다.

단점:

- 정확하고 일관되며 놀랍지 않은 일련의 연산자 오버로드를 제공하려면 약간의 주의가 필요하며 그렇게 하지 않으면 혼란과 버그가 발생할 수 있습니다.
- 연산자를 과도하게 사용하면 특히 오버로드된 연산자의 의미 체계가 규칙을 따르지 않는 경우 코드가 난독화될 수 있습니다.
- 함수 오버로딩의 위험은 연산자 오버로딩에도 똑같이 적용됩니다.
- 연산자 오버로드는 비용이 많이 드는 작업이 저렴하고 기본 제공되는 작업으로 생각하도록 우리의 직관을 속일 수 있습니다.
- 오버로드된 연산자에 대한 호출 사이트를 찾으려면 예를 들어 grep이 아닌 C++ 구문을 인식하는 검색 도구가 필요할 수 있습니다.
- 오버로드된 연산자의 인수 유형이 잘못되면 컴파일러 오류가 아닌 다른 오버로드가 발생할 수 있습니다. 예를 들어, foo < bar while은 한 가지 일을 할 수 있고, while은 &foo < &bar 완전히
  다른 일을 합니다.
- 특정 연산자 과부하는 본질적으로 위험합니다. 단항을 오버로드하면 &오버로드 선언이 표시되는지 여부에 따라 동일한 코드가 다른 의미를 가질 수 있습니다. &&, ||및 (쉼표) 의 오버로드는 , 기본 제공 연산자의
  평가 순서 의미 체계와 일치할 수 없습니다.
- 연산자는 종종 클래스 외부에서 정의되므로 같은 연산자에 대해 다른 정의를 도입하는 다른 파일의 위험이 있습니다. 두 정의가 동일한 바이너리에 연결되면 정의되지 않은 동작이 발생하여 미묘한 런타임 버그로 나타날 수
  있습니다.
- 사용자 정의 리터럴(UDL)을 사용하면 숙련된 C++ 프로그래머에게도 익숙하지 않은 새로운 구문 형식(예 "Hello World"sv: std::string_view("Hello World"). 기존 표기법은 덜
  간결하지만 더 명확합니다.

결론:  
오버로드된 연산자는 의미가 명확하고 놀랍지 않으며 해당 기본 제공 연산자와 일치하는 경우에만 정의합니다.   
예를 들어 `|`은 쉘 스타일 파이프가 아닌 비트 또는 논리 연산.

자신의 유형에 대해서만 연산자를 정의하십시오.
보다 정확하게는 작동하는 유형과 동일한 헤더, `.cc` 파일 및 네임스페이스에서 정의하십시오.
이렇게 하면 유형이 어디에 있든 연산자를 사용할 수 있으므로 다중 정의의 위험이 최소화됩니다.
가능하면 연산자를 템플릿으로 정의하지 마십시오. 가능한 모든 템플릿 인수에 대해 이 규칙을 충족해야 하기 때문입니다.
연산자를 정의하는 경우 의미가 있는 관련 연산자도 정의하고 일관성 있게 정의되었는지 확인하세요.   
예를 들어 `<`를 오버로드하는 경우 모든 비교 연산자를 오버로드하고 `<` 및 `>`가 동일한 인수에 대해 true를 반환하지 않도록 합니다.

수정하지 않는 이진 연산자를 비멤버 함수로 정의하는 것이 좋습니다.
이진 연산자가 클래스 멤버로 정의된 경우 암시적 변환은 오른쪽 인수에 적용되지만 왼쪽 인수에는 적용되지 않습니다.
`a < b`는 컴파일되지만 `b < a`는 컴파일되지 않으면 사용자에게 혼란을 줄 수 있습니다.

연산자 오버로드 정의를 피하기 위해 무리하게 이동하지 마십시오.   
예를 들어 Equals(), CopyFrom() 및 PrintTo()보다는 `==`, `=` 및 `<<`를 정의하는 것이 좋습니다.   
반대로 다른 라이브러리에서 기대한다고 해서 연산자 오버로드를 정의하지 마세요.   
예를 들어 유형에 자연스러운 순서가 없지만 `std::set`에 저장하려는 경우 `<`를 오버로드하는 대신 사용자 정의 비교기를 사용하십시오.

`&&`, `||`, `,`(쉼표) 또는 단항 `&`를 오버로드하지 마십시오.  
연산자 `""`를 오버로드하지 마십시오.
즉, 사용자 정의 리터럴을 도입하지 마십시오.   
다른 사람이 제공한 리터럴(표준 라이브러리 포함)을 사용하지 마십시오.

형식 변환 연산자는 암시적 변환 섹션에서 다룹니다.
`=` 연산자는 복사 생성자 섹션에서 다룹니다. 스트림과 함께 사용하기 위한 `<<` 오버로딩은 스트림 섹션에서 다룹니다.
연산자 오버로딩에도 적용되는 함수 오버로딩에 대한 규칙도 참조하세요

<a id="s6-8-access-control"></a>

### 6.8 접근 제어

상수가 아니면 클래스의 데이터 멤버를 비공개로 만듭니다.
이는 필요한 경우 접근자(보통 const) 형태의 쉬운 상용구를 희생하여 불변성에 대한 추론을 단순화합니다.

<a id="s6-9-declaration-order"></a>

### 6.9 선언 순서

유사한 선언을 함께 그룹화하고 public부분을 더 일찍 배치합니다.

클래스 정의는 일반적으로 `public:` 섹션으로 시작해야 하며 그 다음에는 `protected:`, `private:`가 옵니다.   
비어 있는 섹션은 생략하십시오.

각 섹션 내에서 비슷한 종류의 선언을 함께 그룹화하는 것을 선호하고 다음 순서를 선호합니다.

1. 유형 및 유형 별칭( typedef, using, enum, 중첩 구조체 및 클래스, friend유형)
2. (선택 사항, 구조체에만 해당) static데이터가 아닌 멤버
3. 정적 상수
4. 함수
5. 생성자와 대입 연산자
6. 소멸자
7. 다른 모든 함수( static및 비 static멤버 함수 및 friend함수)
8. 기타 모든 데이터 멤버(정적 및 비정적)

큰 메서드 정의를 클래스 정의에 인라인으로 넣지 마십시오. 일반적으로 사소하거나 성능이 중요하고 매우 짧은 메서드만 인라인으로 정의할 수 있습니다.
자세한 내용은 인라인 함수를 참조하십시오.

<a id="s7-functions"></a>

## 7 함수

<a id="s7-1-inputs-and-outputs"></a>

### 7.1 입력 및 출력

C++ 함수의 출력은 자연스럽게 반환 값을 통해 제공되며 때로는 출력 매개변수(또는 입력/출력 매개변수)를 통해 제공됩니다.

출력 매개변수보다 반환 값을 사용하는 것을 선호합니다. 반환 값은 가독성을 높이고 종종 동일하거나 더 나은 성능을 제공합니다.

값으로 반환하거나 실패하면 참조로 반환하는 것이 좋습니다. null이 될 수 있는 경우가 아니면 포인터를 반환하지 마십시오.

매개변수는 함수에 대한 입력이거나 함수의 출력이거나 둘 다입니다.
선택사항이 아닌 입력 매개변수는 일반적으로 값 또는 const 참조여야 하며, 선택사항이 아닌 출력 및 입력/출력 매개변수는 일반적으로 참조(null일 수 없음)여야 합니다.
일반적으로 std::optional을 사용하여 선택적인 값별 입력을 나타내고 선택 사항이 아닌 형식이 참조를 사용했을 때 const 포인터를 사용합니다.
non-const 포인터를 사용하여 선택적 출력 및 선택적 입력/출력 매개변수를 나타냅니다.

const참조 매개변수가 임시 매개변수에 바인딩되므로 호출 보다 오래 지속되도록 참조 매개변수가 필요한 함수를 정의하지 마십시오 const. 대신 수명 요구 사항을 제거하는 방법(예: 매개 변수 복사)을 찾거나
const 포인터로 전달하고 수명 및 null이 아닌 요구 사항을 문서화합니다.

함수 매개변수를 주문할 때 모든 입력 전용 매개변수를 출력 매개변수 앞에 두십시오. 특히 새 매개변수라는 이유만으로 함수 끝에 새 매개변수를 추가하지 마십시오.
새 입력 전용 매개변수를 출력 매개변수 앞에 배치하십시오. 이것은 엄격하고 빠른 규칙이 아닙니다. 입력 및 출력 모두인 매개변수는 물을 진흙탕으로 만들고 항상 그렇듯이 관련 기능과의 일관성을 유지하려면 규칙을
변경해야 할 수 있습니다. Variadic 함수는 비정상적인 매개변수 순서가 필요할 수도 있습니다.

<a id="s7-2-write-short-functions"></a>

### 7.2 짧은 함수 작성

작고 집중된 기능을 선호하십시오.

때로는 긴 함수가 적절하다는 것을 알고 있으므로 함수 길이에 엄격한 제한이 없습니다. 함수가 약 40줄을 초과하는 경우 프로그램 구조를 손상시키지 않고 분할할 수 있는지 생각해 보십시오.

지금은 긴 함수가 완벽하게 작동하더라도 누군가가 몇 달 안에 이를 수정하면 새로운 동작이 추가될 수 있습니다. 이로 인해 찾기 어려운 버그가 발생할 수 있습니다. 함수를 짧고 단순하게 유지하면 다른 사람이 코드를 더
쉽게 읽고 수정할 수 있습니다. 작은 함수는 테스트하기도 더 쉽습니다.

일부 코드로 작업할 때 길고 복잡한 함수를 찾을 수 있습니다. 기존 코드를 수정하는 것에 겁먹지 마십시오. 그러한 함수로 작업하는 것이 어렵다고 판명되거나, 오류를 디버깅하기 어렵다는 것을 알게 되거나, 여러 다른
컨텍스트에서 그 일부를 사용하려는 경우 함수를 더 작은 단위로 나누는 것을 고려하십시오.

<a id="s7-3-function-overloading"></a>

### 7.3 함수 오버로딩

오버로드된 함수(생성자 포함)는 호출 사이트를 보는 독자가 어떤 오버로드가 호출되고 있는지 먼저 정확히 파악하지 않고도 무슨 일이 일어나고 있는지 잘 알 수 있는 경우에만 사용하십시오.

정의:  
const std::string&를 사용하는 함수를 작성하고 const char*를 사용하는 다른 함수로 오버로드할 수 있습니다. 그러나 이 경우 std::string_view를 대신 고려하십시오.

```cpp
class MyClass {
 public:
  void Analyze(const std::string &text);
  void Analyze(const char *text, size_t textlen);
};
```

장점:  
오버로딩은 동일한 이름의 함수가 다른 인수를 가질 수 있도록 하여 코드를 보다 직관적으로 만들 수 있습니다. 템플릿화된 코드에 필요할 수 있으며 방문자에게 편리할 수 있습니다.

또는 ref 자격 에 기반한 오버로딩은 const유틸리티 코드를 더 유용하고 효율적으로 만들거나 둘 다 만들 수 있습니다.

단점:  
함수가 인수 유형만으로 오버로드되는 경우 독자는 무슨 일이 일어나고 있는지 알려주기 위해 C++의 복잡한 일치 규칙을 이해해야 할 수 있습니다. 또한 파생 클래스가 함수의 변형 중 일부만 재정의하는 경우 많은
사람들이 상속의 의미를 혼동합니다.

결론:  
변형 간에 의미론적 차이가 없을 때 함수를 오버로드할 수 있습니다. 이러한 오버로드는 유형, 한정자 또는 인수 개수가 다를 수 있습니다. 그러나 이러한 호출을 읽는 사람은 오버로드 집합의 어떤 구성원이 선택되었는지
알 필요가 없으며 집합에서 무언가가 호출되고 있다는 것만 알면 됩니다.
오버로드 세트의 모든 항목을 헤더의 단일 주석으로 문서화할 수 있다면 잘 설계된 오버로드 세트라는 좋은 신호입니다.

<a id="s7-4-default-arguments"></a>

### 7.4 기본 인수

기본값이 항상 동일한 값을 갖도록 보장되는 경우 비가상 함수에서 기본 인수가 허용됩니다. 함수 오버로딩 과 동일한 제한을 따르고 기본 인수로 얻은 가독성이 아래의 단점보다 크지 않은 경우 오버로드된 함수를
선호합니다.

장점:  
종종 기본값을 사용하는 함수가 있지만 때때로 기본값을 무시하고 싶을 때가 있습니다. 기본 매개변수를 사용하면 드문 예외에 대해 많은 함수를 정의하지 않고도 이 작업을 쉽게 수행할 수 있습니다. 함수를 오버로드하는
것과 비교하여 기본 인수는 구문이 더 깔끔하며 상용구가 적고 `필수` 및 `선택` 인수가 더 명확하게 구분됩니다.

단점:  
기본 인수는 오버로드된 함수의 의미 체계를 달성하는 또 다른 방법이므로 함수를 오버로드하지 않는 모든 이유가 적용됩니다.

가상 함수 호출에서 인수의 기본값은 대상 개체의 정적 유형에 의해 결정되며 지정된 함수의 모든 재정의가 동일한 기본값을 선언한다는 보장이 없습니다.

기본 매개변수는 각 호출 사이트에서 재평가되어 생성된 코드를 부풀릴 수 있습니다. 독자는 각 호출에서 변경하는 대신 선언에서 기본값의 값이 고정될 것으로 기대할 수도 있습니다.

함수 포인터는 함수 서명이 호출 서명과 일치하지 않는 경우가 많기 때문에 기본 인수가 있으면 혼란스럽습니다. 함수 오버로드를 추가하면 이러한 문제를 피할 수 있습니다.

결론:  
기본 인수는 제대로 작동하지 않는 가상 함수에서 금지되며 지정된 기본값이 평가된 시기에 따라 동일한 값으로 평가되지 않을 수 있습니다.
(예를 들어, void f(int n = counter++);를 사용하지 마십시오)

다른 경우에 기본 인수는 위의 단점을 극복할 수 있을 만큼 함수 선언의 가독성을 향상시킬 수 있으므로 허용됩니다. 확실하지 않은 경우 과부하를 사용하십시오.

<a id="s7-5-trailing-return-type-syntax"></a>

### 7.5 후행 반환 유형 구문

일반 구문(선행 반환 유형)을 사용하는 것이 비실용적이거나 가독성이 훨씬 떨어지는 경우에만 후행 반환 유형을 사용하십시오.

정의:  
C++에서는 두 가지 다른 형태의 함수 선언을 허용합니다. 이전 형식에서는 반환 유형이 함수 이름 앞에 나타납니다

```cpp
int foo(int x);
```

최신 형식은 함수 이름 앞에 `auto` 키워드를 사용하고 인수 목록 뒤에 후행 반환 유형을 사용합니다.
예를 들어 위의 선언은 다음과 같이 작성할 수 있습니다

```cpp
auto foo(int x) -> int;
```

후행 반환 형식은 함수의 범위에 있습니다.
이것은 간단한 경우에는 차이가 없지만 int클래스 범위에서 선언된 유형이나 함수 매개변수로 작성된 유형과 같은 보다 복잡한 경우에는 중요합니다.

장점:  
후행 반환 형식은 람다 식 의 반환 형식을 명시적으로 지정하는 유일한 방법입니다.
어떤 경우에는 컴파일러가 람다의 반환 유형을 추론할 수 있지만 모든 경우에 그런 것은 아닙니다.
컴파일러가 이를 자동으로 추론할 수 있는 경우에도 때로는 명시적으로 지정하는 것이 독자에게 더 명확할 수 있습니다.

때로는 함수의 매개변수 목록이 이미 나타난 후에 반환 유형을 지정하는 것이 더 쉽고 읽기 쉽습니다.
반환 유형이 템플릿 매개변수에 따라 달라지는 경우 특히 그렇습니다.

```cpp
    template <typename T, typename U>
    auto add(T t, U u) -> decltype(t + u);
```

vs

```cpp
    template <typename T, typename U>
    decltype(declval<T&>() + declval<U&>()) add(T t, U u);
```

단점:  
후행 반환 유형 구문은 비교적 새롭고 C 및 Java와 같은 C++ 유사 언어에는 유사하지 않으므로 일부 독자는 익숙하지 않을 수 있습니다.

기존 코드 베이스에는 새 구문을 사용하도록 변경되지 않을 엄청난 수의 함수 선언이 있으므로 현실적인 선택은 이전 구문만 사용하거나 둘을 혼합하여 사용하는 것입니다.
단일 버전을 사용하는 것이 스타일의 통일성을 위해 더 좋습니다.

결론:  
대부분의 경우 반환 유형이 함수 이름 앞에 오는 이전 스타일의 함수 선언을 계속 사용하십시오.
새로운 후행 반환 유형 형식은 필요한 경우(예: 람다) 또는 함수의 매개 변수 목록 뒤에 유형을 배치하여 훨씬 더 읽기 쉬운 방식으로 유형을 작성할 수 있는 경우에만 사용하십시오. 후자의 경우는 드물어야 합니다.
대부분 상당히 복잡한 템플릿 코드에서 문제가 되므로 대부분의 경우 권장되지 않습니다.

<a id="s8-orther-c++-features"></a>

## 8 기타 C++ 기능

<a id="s8-1-rvalue-references"></a>

### 8.1 Rvalue 참조

아래 나열된 특정 특수한 경우에만 rvalue 참조를 사용하십시오.

정의:  
Rvalue 참조는 임시 개체에만 바인딩할 수 있는 참조 유형입니다.

장점:

- 이동 생성자(클래스 유형에 대한 rvalue 참조를 사용하는 생성자)를 정의하면 값을 복사하는 대신 이동할 수 있습니다. 예를 들어 v1이 std::vector<std::string>인 경우 auto v2(
  std::move(v1))는 많은 양의 데이터를 복사하는 대신 단순한 포인터 조작으로 이어질 것입니다. 대부분의 경우 이는 상당한 성능 향상을 가져올 수 있습니다.
- Rvalue 참조를 사용하면 이동할 수 있지만 복사할 수 없는 유형을 구현할 수 있습니다. 이는 복사에 대한 합리적인 정의가 없지만 함수 인수로 전달하고 컨테이너에 넣는 등의 유형에 유용할 수 있습니다.
- std::move는 std::unique_ptr과 같은 일부 표준 라이브러리 유형을 효과적으로 사용하는 데 필요합니다.
- rvalue 참조 토큰을 사용하는 전달 참조는 인수를 다른 함수로 전달하고 인수가 임시 개체 및/또는 const인지 여부에 관계없이 작동하는 일반 함수 래퍼를 작성할 수 있도록 합니다. 이것을 '완벽한
  전달'이라고 합니다.

단점:

- Rvalue 참조는 아직 널리 이해되지 않았습니다. 참조 축소 및 전달 참조에 대한 특별 공제 규칙과 같은 규칙은 다소 모호합니다.
- Rvalue 참조는 종종 오용됩니다. rvalue 참조를 사용하는 것은 함수 호출 후 인수가 유효한 지정된 상태를 가질 것으로 예상되거나 이동 작업이 수행되지 않는 서명에서 직관적이지 않습니다.

결론:  
다음을 제외하고 rvalue 참조를 사용하거나 && 한정자를 메서드에 적용하지 마십시오.

- 이동 생성자와 이동 할당 연산자를 정의하는 데 사용할 수 있습니다(복사 가능 및 이동 가능 유형에 설명된 대로).
- `*this`를 논리적으로 "소비"하여 사용할 수 없거나 비어 있는 상태로 두는 `&&-qualified` 메서드를 정의하는 데 사용할 수 있습니다. 이것은 메서드 한정자(함수 서명의 닫는 괄호 뒤에 오는)에만
  적용된다는 점에 유의하십시오. 일반 함수 매개변수를 "소비"하려면 값으로 전달하는 것이 좋습니다.
- 완벽한 전달을 지원하기 위해 `std::forward`와 함께 전달 참조를 사용할 수 있습니다.
- 하나는 `Foo&&`를 사용하고 다른 하나는 `const Foo&`를 사용하는 것과 같은 오버로드 쌍을 정의하는 데 사용할 수 있습니다. 일반적으로 선호되는 솔루션은 단순히 값을 전달하는 것이지만 오버로드된 함수
  쌍은 때때로 더 나은 성능을 제공하고 다양한 유형을 지원해야 하는 일반 코드에서 때때로 필요합니다. 항상 그렇듯이 성능을 위해 더 복잡한 코드를 작성하는 경우 실제로 도움이 된다는 증거가 있는지 확인하십시오.

<a id="s8-2-friends"></a>

### 8.2 Friends

정당한 범위 내에서 `Friend` 클래스와 기능을 사용할 수 있습니다.

`Friend`는 일반적으로 동일한 파일에서 정의되어야 독자가 클래스의 전용 멤버 사용을 찾기 위해 다른 파일을 찾을 필요가 없습니다.
`friend`의 일반적인 용도는 `FooBuilder 클래스`를 `Foo`의 `Friend`로 만들어 이 상태를 세상에 노출하지 않고 `Foo`의 내부 상태를 올바르게 구성할 수 있도록 하는 것입니다.
경우에 따라 단위 테스트 클래스를 테스트하는 클래스의 `Friend`로 만드는 것이 유용할 수 있습니다.

<a id="s8-3-exceptions"></a>

### 8.3 예외 처리

우리는 C++ 예외를 사용하지 않습니다.

장점:

- 예외는 모호하고 오류가 발생하기 쉬운 오류 코드 기록 없이 더 높은 수준의 응용 프로그램이 깊게 중첩된 함수에서 "발생할 수 없는" 오류를 처리하는 방법을 결정할 수 있도록 합니다.
- 예외는 대부분의 다른 현대 언어에서 사용됩니다. C++에서 사용하면 다른 사람들에게 익숙한 Python, Java 및 C++와 더 일관성이 있습니다.
- 일부 타사 C++ 라이브러리는 예외를 사용하며 내부적으로 예외를 해제하면 해당 라이브러리와 통합하기가 더 어려워집니다.
- 예외는 생성자가 실패하는 유일한 방법입니다. 팩토리 함수나 메서드로 이것을 시뮬레이션할 수 Init()있지만, 각각 힙 할당이나 새로운 "무효" 상태가 필요합니다.
- 예외는 테스트 프레임워크에서 정말 편리합니다.

단점:

- 기존 함수에 `throw 문`을 추가할 때 모든 전이 호출자를 검사해야 합니다. 그들은 최소한 기본적인 예외 안전 보장을 해야 하거나, 예외를 포착하지 않고 결과적으로 종료되는 프로그램에 만족해야 합니다. 예를
  들어 `f()`가 `g()`를 호출하고 `h()`를 호출하고 `h`가 `f`가 포착하는 예외를 `throw`하는 경우 `g`는 주의해야 합니다. 그렇지 않으면 제대로 정리되지 않을 수 있습니다.
- 보다 일반적으로 예외는 코드를 살펴봄으로써 프로그램의 제어 흐름을 평가하기 어렵게 만듭니다. 함수는 예상하지 못한 위치에서 반환될 수 있습니다. 이로 인해 유지 관리 및 디버깅이 어려워집니다. 예외를 사용할 수
  있는 방법과 위치에 대한 몇 가지 규칙을 통해 이 비용을 최소화할 수 있지만 개발자가 알고 이해해야 하는 비용이 더 많이 듭니다.
- 예외 안전에는 RAII와 다른 코딩 방식이 모두 필요합니다. 올바른 예외 안전 코드를 쉽게 작성하려면 많은 지원 장치가 필요합니다. 또한 독자가 전체 호출 그래프를 이해할 필요가 없도록 예외 안전 코드는 영구
  상태에 쓰는 논리를 "커밋" 단계로 분리해야 합니다. 이렇게 하면 이점과 비용이 모두 발생합니다(아마도 커밋을 격리하기 위해 코드를 난독화해야 하는 경우). 예외를 허용하면 가치가 없는 경우에도 항상 비용을
  지불해야 합니다.
- 예외를 켜면 생성된 각 바이너리에 데이터가 추가되어 컴파일 시간이 늘어나고(약간) 주소 공간 압력이 증가할 수 있습니다.
- 예외의 가용성은 개발자가 적절하지 않을 때 예외를 던지거나 그렇게 하는 것이 안전하지 않을 때 예외에서 복구하도록 장려할 수 있습니다. 예를 들어 잘못된 사용자 입력으로 인해 예외가 발생해서는 안 됩니다. 이러한
  제한 사항을 문서화하려면 스타일 가이드를 더 길게 만들어야 합니다!

결론:  
표면적으로는 예외를 사용하는 이점이 특히 새 프로젝트에서 비용보다 큽니다.
그러나 기존 코드의 경우 예외 도입은 모든 종속 코드에 영향을 미칩니다.
예외가 새 프로젝트를 넘어 전파될 수 있는 경우 새 프로젝트를 예외가 없는 기존 코드에 통합하는 것도 문제가 됩니다.
대부분의 기존 C++ 코드는 예외를 처리할 준비가 되어 있지 않기 때문에 예외를 생성하는 새로운 코드를 채택하기가 비교적 어렵습니다.

기존 코드가 예외를 허용하지 않는다는 점을 감안할 때 예외를 사용하는 비용은 새 프로젝트의 비용보다 다소 큽니다.
변환 프로세스는 느리고 오류가 발생하기 쉽습니다.
오류 코드 및 어설션과 같은 예외에 대한 사용 가능한 대안이 상당한 부담을 초래한다고 생각하지 않습니다.

예외 사용에 대한 우리의 조언은 철학적 또는 도덕적 근거가 아니라 실용적인 근거에 입각한 것입니다.

<a id="s8-4-noexcept"></a>

### 8.4 noexcept

유용하고 올바른 경우 noexcept를 지정하십시오.

정의:  
noexcept 지정자는 함수가 예외를 throw할지 여부를 지정하는 데 사용됩니다. noexcept로 표시된 함수에서 예외가 탈출하면 프로그램은 std::terminate를 통해 충돌합니다.

noexcept 연산자는 식이 예외를 throw하지 않도록 선언된 경우 true를 반환하는 컴파일 시간 검사를 수행합니다.

장점:

- 이동 생성자를 noexcept로 지정하면 경우에 따라 성능이 향상됩니다. 예를 들어 `std::vector<T>::resize()`는 `T`의 이동 생성자가 noexcept인 경우 객체를 복사하는 대신
  이동합니다.
- 함수에 noexcept를 지정하면 예외가 활성화된 환경에서 컴파일러 최적화를 트리거할 수 있습니다. 예를 들어 컴파일러는 noexcept 지정자로 인해 예외를 throw할 수 없다는 것을 알고 있는 경우 스택
  해제를 위한 추가 코드를 생성할 필요가 없습니다.

단점:

- 예외가 비활성화된 이 가이드를 따르는 프로젝트에서는 noexcept 지정자가 올바른지 확인하기 어렵고 정확성이 무엇을 의미하는지 정의하기조차 어렵습니다.
- 감지하기 어려운 방식으로 호출자가 의존할 수 있는 보장을 제거하기 때문에 noexcept를 실행 취소하는 것은 불가능하지는 않더라도 어렵습니다.

결론:  
함수의 의도된 의미 체계를 정확하게 반영하는 경우, 즉 함수 본문 내에서 어떤 식으로든 예외가 발생하면 치명적인 오류를 나타내는 경우 성능에 유용할 때 noexcept를 사용할 수 있습니다.
이동 생성자에 대한 noexcept가 의미 있는 성능상의 이점이 있다고 가정할 수 있습니다.
다른 기능에 noexcept를 지정하여 상당한 성능상의 이점이 있다고 생각되면 프로젝트 리드와 논의하십시오.

예외가 완전히 비활성화된 경우(예: 대부분의 Google C++ 환경)를 제외하고 사용하지 않기를 권장합니다.
그렇지 않으면 함수가 잠재적으로 발생할 수 있는 몇 가지 경우에만 false를 평가하는 방식으로 간단한 조건과 함께 조건부 noexcept 지정자를 사용합니다.
테스트에는 관련된 작업이 throw할 수 있는지 여부(예: 이동 생성 개체의 경우 std::is_nothrow_move_constructible) 또는 할당이 throw할 수 있는지 여부(예: 표준 기본 할당의 경우
absl::default_allocator_is_nothrow)에 대한 유형 특성 검사가 포함될 수 있습니다.
대부분의 경우 예외의 가능한 유일한 원인은 할당 실패(할당 실패로 인한 경우를 제외하고 이동 생성자는 throw해서는 안 된다고 생각합니다)이며, 메모리 고갈을 예외 조건이 아닌 치명적 오류로 처리하는 것이 적절한
애플리케이션이 많이 있습니다.
프로그램에서 복구를 시도해야 합니다. 다른 잠재적 오류의 경우에도 가능한 모든 예외 발생 시나리오를 지원하는 것보다 인터페이스 단순성을 우선시해야 합니다. 그리고 무조건 noexcept로 만드세요.

<a id="s8-5-run-time-type-information"></a>

### 8.5 Run-Time Type Informaint(RTTI)

런타임 유형 정보(RTTI)를 사용하지 마십시오.

정의:  
RTTI를 통해 프로그래머는 런타임에 개체의 C++ 클래스를 쿼리할 수 있습니다. 이는 typeid 또는 dynamic_cast를 사용하여 수행됩니다.

장점:  
RTTI에 대한 표준 대안(아래 설명)은 문제의 클래스 계층 구조를 수정하거나 재설계해야 합니다.
때로는 이러한 수정이 실행 불가능하거나 바람직하지 않은 경우가 있습니다. 특히 널리 사용되거나 완성된 코드에서 그러합니다.

RTTI는 일부 단위 테스트에서 유용할 수 있습니다.
예를 들어 새로 생성된 객체가 예상되는 동적 유형을 가지고 있는지 확인해야 하는 팩토리 클래스 테스트에 유용합니다.
객체와 모의 객체 간의 관계를 관리하는 데에도 유용합니다.

RTTI는 여러 추상 객체를 고려할 때 유용합니다.

```cpp
bool Base::Equal(Base* other) = 0;
bool Derived::Equal(Base* other) {
  Derived* that = dynamic_cast<Derived*>(other);
  if (that == nullptr)
    return false;
  ...
}
```

단점:  
런타임에 개체 유형을 자주 쿼리하는 것은 디자인 문제를 의미합니다.
런타임 시 개체 유형을 알아야 하는 경우 클래스 계층 구조의 설계에 결함이 있음을 나타내는 경우가 많습니다.

RTTI를 무분별하게 사용하면 코드를 유지 관리하기가 어렵습니다.
유형 기반 결정 트리 또는 코드 전체에 흩어져 있는 스위치 문으로 이어질 수 있으며 추가 변경 시 모두 검사해야 합니다.

결론:  
RTTI는 합법적인 용도가 있지만 남용되기 쉬우므로 사용 시 주의해야 합니다.
단위 테스트에서는 자유롭게 사용할 수 있지만 다른 코드에서는 가능하면 사용하지 마십시오.
특히 새 코드에서 RTTI를 사용하기 전에 두 번 생각하십시오.
개체의 클래스에 따라 다르게 동작하는 코드를 작성해야 하는 경우 유형 쿼리에 대한 다음 대안 중 하나를 고려하십시오.

- 가상 메서드는 특정 하위 클래스 유형에 따라 다른 코드 경로를 실행하는 기본 방법입니다. 이것은 개체 자체 내에 작업을 넣습니다.
- 작업이 개체 외부에 속하고 대신 일부 처리 코드에 속하는 경우 방문자 디자인 패턴과 같은 이중 디스패치 솔루션을 고려하십시오. 이를 통해 개체 외부의 기능이 내장 유형 시스템을 사용하여 클래스 유형을 결정할 수
  있습니다.

프로그램의 논리가 기본 클래스의 지정된 인스턴스가 실제로 특정 파생 클래스의 인스턴스임을 보장하는 경우 dynamic_cast를 개체에서 자유롭게 사용할 수 있습니다. 일반적으로 그러한 상황에서 대안으로
static_cast를 사용할 수 있습니다.

유형에 기반한 결정 트리는 코드가 잘못된 방향으로 가고 있다는 강력한 표시입니다.

```cpp
if (typeid(*data) == typeid(D1)) {
  ...
} else if (typeid(*data) == typeid(D2)) {
  ...
} else if (typeid(*data) == typeid(D3)) {
...
```

이와 같은 코드는 일반적으로 추가 하위 클래스가 클래스 계층 구조에 추가될 때 중단됩니다. 또한 하위 클래스의 속성이 변경되면 영향을 받는 모든 코드 세그먼트를 찾아 수정하기가 어렵습니다.

RTTI와 같은 해결 방법을 직접 구현하지 마십시오. RTTI에 반대하는 주장은 유형 태그가 있는 클래스 계층 구조와 같은 해결 방법에도 마찬가지로 적용됩니다. 또한 해결 방법은 진정한 의도를 위장합니다.

<a id="s8-6-casting"></a>

### 8.6 캐스팅

`static_cast<float>(double_value)`와 같은 C++ 스타일 캐스트를 사용하거나 `int64_t y = int64_t{1} << 42`와 같은 산술 유형의 변환을 위해 중괄호 초기화를
사용하십시오.
캐스트가 무효화되지 않는 한 `(int)x`와 같은 캐스트 형식을 사용하지 마십시오.
`T`가 클래스 유형인 경우에만 `T(x)`와 같은 캐스트 형식을 사용할 수 있습니다.

정의:
C++는 캐스트 작업 유형을 구분하는 C와 다른 캐스트 시스템을 도입했습니다.

장점:  
C 캐스트의 문제점은 작업의 모호성입니다. 때로는 변환(예: (int)3.5)을 수행하고 때로는 캐스트(예: (int)"hello")를 수행합니다.
중괄호 초기화 및 C++ 캐스트는 종종 이러한 모호성을 피하는 데 도움이 될 수 있습니다. 또한 C++ 캐스트는 검색할 때 더 잘 보입니다.

단점:  
C++ 스타일의 캐스트 구문은 장황하고 번거롭습니다

결론:  
일반적으로 C 스타일 캐스트를 사용하지 마십시오. 대신 명시적 유형 변환이 필요한 경우 이러한 C++ 스타일 캐스트를 사용하십시오.

- 중괄호 초기화를 사용하여 산술 유형(예: int64_t{x})을 변환합니다. 변환으로 인해 정보가 손실될 수 있는 경우 코드가 컴파일되지 않기 때문에 이것이 가장 안전한 접근 방식입니다. 구문도 간결합니다.
- 예를 들어 `Foo*`를 `SuperclassOfFoo*`로 캐스팅하거나 `Foo*`를 `const Foo*`로 캐스팅하는 것과 같이 유형 계층을 안전하게 캐스팅하려면 `absl::implicit_cast`를
  사용하세요. C++은 일반적으로 이 작업을 자동으로 수행하지만 일부 상황에서는 `?:` 연산자 사용과 같은 명시적인 업캐스트가 필요합니다.
- 클래스에서 해당 슈퍼클래스로 포인터를 명시적으로 업캐스트해야 하거나 슈퍼클래스에서 서브클래스로 포인터를 명시적으로 캐스팅해야 하는 경우 값 변환을 수행하는 C 스타일 캐스트와 동등한
  것으로 `static_cast`를 사용합니다. 이 마지막 경우에는 개체가 실제로 하위 클래스의 인스턴스인지 확인해야 합니다.
- `const_cast`를 사용하여 `const` 한정자를 제거합니다(const 참조).
- `reinterpret_cast`를 사용하여 포인터 유형과 정수 및 `void*`를 포함한 기타 포인터 유형 간의 안전하지 않은 변환을 수행합니다. 수행 중인 작업을 알고 있고 앨리어싱 문제를 이해하는 경우에만
  사용하십시오. 또한 대체 `absl::bit_cast`를 고려하십시오.
- `absl::bit_cast`를 사용하여 `double`의 비트를 `int64_t`로 해석하는 것과 같이 동일한 크기의 다른 유형(장난 유형)을 사용하여 값의 원시 비트를 해석합니다.

<a id="8-7-streams"></a>

### 8.7 스트림

적절한 경우 스트림을 사용하고 "단순" 사용법을 고수하십시오.
값을 나타내는 유형에 대해서만 스트리밍을 위해 `<<`를 오버로드하고 구현 세부 정보가 아닌 사용자에게 표시되는 값만 작성합니다.

정의:  
스트림은 표준 헤더 `<iostream>`으로 예시된 것처럼 C++의 표준 I/O 추상화입니다. 주로 디버그 로깅 및 테스트 진단을 위해 Google 코드에서 널리 사용됩니다.

장점:  
`<<` 및 `>>` 스트림 연산자는 쉽게 배우고 이식 가능하며 재사용 및 확장 가능한 형식화된 I/O용 API를 제공합니다.
대조적으로 `printf`는 사용자 정의 유형은 말할 것도 없고 `std::string`도 지원하지 않으며 이식성 있게 사용하기가 매우 어렵습니다.
`printf`는 또한 해당 함수의 약간 다른 수많은 버전 중에서 선택하고 수십 개의 변환 지정자를 탐색해야 합니다.

스트림은 `std::cin`, `std::cout`, `std::cerr` 및 `std::clog`를 통해 콘솔 I/O에 대한 최고 수준의 지원을 제공합니다.
C API도 마찬가지지만 입력을 수동으로 버퍼링해야 하는 필요성 때문에 방해를 받습니다.

단점:

- 스트림 형식은 스트림 상태를 변경하여 구성할 수 있습니다. 이러한 변형은 지속적이므로 다른 코드가 건드릴 수 있는 경우마다 알려진 상태로 복원하기 위해 노력하지 않는 한 코드의 동작은 스트림의 전체 이전 기록에
  의해 영향을 받을 수 있습니다. 사용자 코드는 내장된 상태를 수정할 수 있을 뿐만 아니라 등록 시스템을 통해 새로운 상태 변수와 동작을 추가할 수 있습니다.
- 스트리밍 코드에서 코드와 데이터가 혼합되는 방식, 연산자 오버로딩 사용(예상과 다른 오버로드 선택 가능)으로 인해 스트림 출력을 정확하게 제어하기 어렵습니다.
- `<<` 연산자 체인을 통해 출력을 구축하는 관행은 단어 순서를 코드에 굽고 스트림의 현지화 지원에 결함이 있기 때문에 국제화를 방해합니다.
- 스트림 API는 미묘하고 복잡하므로 프로그래머가 이를 효과적으로 사용하려면 경험을 개발해야 합니다.
- `<<`의 많은 오버로드를 해결하는 것은 컴파일러에 매우 비용이 많이 듭니다. 대규모 코드 베이스에서 광범위하게 사용될 경우 구문 분석 및 의미 체계 분석 시간의 20%를 소비할 수 있습니다.

결론:  
작업에 가장 적합한 도구인 경우에만 스트림을 사용하십시오.
이것은 일반적으로 I/O가 임시적이고 로컬이며 사람이 읽을 수 있고 최종 사용자가 아닌 다른 개발자를 대상으로 하는 경우입니다.
주변의 코드 및 전체 코드베이스와 일관성을 유지하십시오.
문제에 대해 확립된 도구가 있는 경우 해당 도구를 대신 사용하십시오.
특히 로깅 라이브러리는 일반적으로 진단 출력의 경우 `std::cerr` 또는 `std::clog`보다 더 나은 선택이며 `absl/strings` 또는 이와 동등한 라이브러리는
일반적으로 `std::stringstream`보다 더 나은 선택입니다.

외부 사용자를 대면하거나 신뢰할 수 없는 데이터를 처리하는 I/O에 스트림을 사용하지 마십시오. 대신 적절한 템플릿 라이브러리를 찾아 사용하여 국제화, 현지화 및 보안 강화와 같은 문제를 처리하세요.

스트림을 사용하는 경우 `imbue()`, `xalloc()` 및 `register_callback()`과 같은 스트림 API의 상태 저장 부분(오류 상태 제외)을 피하십시오. 스트림 조작자 또는 형식화 플래그 대신
명시적 형식화 함수(예: `absl::StreamFormat()`)를 사용하여 숫자 기준, 정밀도 또는 패딩과 같은 형식화 세부사항을 제어하십시오.

유형이 값을 나타내는 경우에만 유형에 대한 스트리밍 연산자로 `<<`를 오버로드하고 `<<` 해당 값의 사람이 읽을 수 있는 문자열 표현을 작성합니다. <<의 출력에 구현 세부 정보를 노출하지 마십시오. 디버깅을
위해 개체 내부를 인쇄해야 하는 경우 명명된 함수를 대신 사용하십시오(`DebugString()`이라는 메서드가 가장 일반적인 규칙임).

<a id="s8-8-preincrement-and-predecrement"></a>

### 8.8 선행 증가 및 선행 감소

접미사 의미 체계가 필요하지 않은 경우 증가 및 감소 연산자의 접두사 형식(`++i`)을 사용합니다.

정의:  
변수가 증가(`++i` 또는 `i++`)되거나 감소(`--i` 또는 `i--`)되고 표현식의 값이 사용되지 않는 경우 사전 증가(감소) 또는 사후 증가(감소) 여부를 결정해야 합니다.

장점:  
접미사 증가/감소 식은 수정되기 전의 값으로 평가됩니다.
이로 인해 더 간결하지만 읽기 어려운 코드가 생성될 수 있습니다.
접두사 형식은 일반적으로 더 읽기 쉽고 결코 덜 효율적이지 않으며 작업 전과 같이 값의 복사본을 만들 필요가 없기 때문에 더 효율적일 수 있습니다.

단점:  
특히 for 루프에서 식 값이 사용되지 않는 경우에도 후행 증가를 사용하는 전통이 C에서 발전했습니다.

결론:  
코드가 후위 증가/감소 식의 결과를 명시적으로 필요로 하지 않는 한 접두사 증가/감소를 사용합니다.

<a id="s8-9-use-of-const"></a>

### 8.9 const 사용

API에서는 의미가 있을 때마다 const를 사용합니다. constexpr은 일부 const 사용에 더 나은 선택입니다.

정의:  
변수가 변경되지 않았음을 나타내기 위해 선언된 변수 및 매개변수 앞에 키워드 `const`를 붙일 수 있습니다(예: const int foo).
클래스 함수는 함수가 클래스 멤버 변수의 상태를 변경하지 않음을 나타내는 `const` 한정자를 가질 수 있습니다

```cpp
class Foo { 
  int Bar(char c) const; 
};
```

장점:  
사람들이 변수가 어떻게 사용되는지 더 쉽게 이해할 수 있습니다.
컴파일러가 더 나은 유형 검사를 수행하고 더 나은 코드를 생성할 수 있습니다.
호출하는 함수가 변수를 수정할 수 있는 방법에 제한이 있다는 것을 알고 있기 때문에 사람들이 프로그램 정확성을 확신하도록 도와줍니다.
다중 스레드 프로그램에서 잠금 없이 사용하기에 안전한 기능을 사람들이 알 수 있도록 도와줍니다.

단점:  
const는 입소문입니다. const 변수를 함수에 전달하면 해당 함수의 프로토타입에 const가 있어야 합니다(또는 변수에 const_cast가 필요함).
이는 라이브러리 함수를 호출할 때 특히 문제가 될 수 있습니다.

결론:
의미 있고 정확할 때마다 API(즉, 함수 매개 변수, 메서드 및 비지역 변수)에서 const를 사용하는 것이 좋습니다.
이는 작업이 변경할 수 있는 개체에 대한 대부분의 컴파일러 검증 문서를 일관되게 제공합니다.
읽기와 쓰기를 구별하는 일관되고 신뢰할 수 있는 방법을 갖는 것은 스레드로부터 안전한 코드를 작성하는 데 중요하며 다른 많은 컨텍스트에서도 유용합니다.
특히

- 함수가 참조 또는 포인터에 의해 전달된 인수를 수정하지 않는다고 보장하는 경우 해당 함수 매개 변수는 각각 `const`에 대한 참조`(const T&)` 또는 `const`에 대한 포인터`(const T*)`
  여야 합니다.
- 값으로 전달되는 함수 매개변수의 경우 const는 호출자에게 영향을 주지 않으므로 함수 선언에서 권장되지 않습니다.
- 메서드가 개체의 논리적 상태를 변경하지 않는 한(또는 사용자가 `비 const` 참조를 반환하여 해당 상태를 수정할 수 있도록 하는 경우가 아니면) 메서드를 `const`로 선언하십시오.

지역 변수에 const를 사용하는 것은 권장되지도 권장되지도 않습니다.

클래스의 모든 const 작업은 서로 동시에 호출해도 안전해야 합니다. 이것이 가능하지 않은 경우 클래스는 "스레드 안전하지 않음"으로 명확하게 문서화되어야 합니다.

<a id="s8-10-use-of-constexpr"></a>

### 8.10 constexpr 사용

실제 상수를 정의하거나 상수 초기화를 보장하는 데 사용합니다 .

정의:  
일부 변수는 변수가 진정한 상수임을 나타내기 위해 선언될 수 있습니다.
즉, 컴파일/링크 시간에 고정됩니다. 일부 함수 및 생성자는 변수를 정의하는 데 사용할 수 있도록 선언할 수 있습니다

장점:  
onstexpr을 사용하면 리터럴이 아닌 부동 소수점 식으로 상수를 정의할 수 있습니다.

- 사용자 정의 유형의 상수 정의
- 함수 호출을 통한 상수 정의

단점:  
미리 constexpr로 표시하면 나중에 다운그레이드해야 하는 경우 마이그레이션 문제가 발생할 수 있습니다.
constexpr 함수 및 생성자에서 허용되는 것에 대한 현재 제한으로 인해 이러한 정의에서 모호한 해결 방법이 필요할 수 있습니다.

결론:  
constexpr 정의를 사용하면 인터페이스의 상수 부분에 대한 보다 강력한 사양을 사용할 수 있습니다.
진정한 상수와 그 정의를 지원하는 함수를 지정하려면 constexpr을 사용하십시오.
constexpr과 함께 사용할 수 있도록 함수 정의를 복잡하게 만들지 마십시오.
강제로 인라인하기 위해 constexpr을 사용하지 마십시오.

<a id="s8-11-integer-types"></a>

### 8.11 정수 타입

내장된 C++ 정수 유형 중에서 사용되는 유일한 유형은 int입니다.
프로그램에 다른 크기의 정수 유형이 필요한 경우 `int16_t`와 같은 `<cstdint>`의 정확한 너비 정수 유형을 사용하십시오.
2^31보다 크거나 같을 수 있는 값이 있는 경우 `int64_t`와 같은 64비트 유형을 사용하십시오.
값이 int에 비해 너무 크지 않더라도 더 큰 유형이 필요할 수 있는 중간 계산에 사용될 수 있음을 명심하십시오.
확실하지 않은 경우 더 큰 유형을 선택하십시오.

정의:  
C++은 `int`와 같은 정수 유형에 대해 정확한 크기를 지정하지 않습니다.
현대 아키텍처의 일반적인 크기는 `short`의 경우 16비트, `int`의 경우 32비트, `long`의 경우 32 또는 64비트, `long`의 경우 64비트이지만 플랫폼마다 특히 `long`의 경우 다른 선택을
합니다.

장점:  
선언의 통일성

단점:
C++에서 정수 유형의 크기는 컴파일러와 아키텍처에 따라 다를 수 있습니다.

결론:  
표준 라이브러리 헤더 `<cstdint>`는 `int16_t`, `uint32_t`, `int64_t` 등과 같은 유형을 정의합니다.
정수의 크기에 대한 보장이 필요할 때 항상 `short`, `unsigned long`, `long` 등과 같은 유형을 우선적으로 사용해야 합니다.
내장 정수 유형 중 `int`만 사용해야 합니다. 적절한 경우 `size_t` 및 `ptrdiff_t`와 같은 표준 유형 별칭을 사용할 수 있습니다.

우리는 루프 카운터와 같이 너무 크지 않을 것이라는 것을 알고 있는 정수에 대해 `int`를 매우 자주 사용합니다.
그런 일에는 평범한 오래된 `int`를 사용하십시오. `int`가 32비트 이상이라고 가정해야 하지만 32비트보다 크다고 가정하지 마십시오.
64비트 정수 유형이 필요한 경우 `int64_t` 또는 `uint64_t`를 사용하십시오.

우리가 알고 있는 "큰" 정수의 경우 `int64_t`를 사용하십시오.

숫자가 아닌 비트 패턴을 나타내는 것과 같은 타당한 이유가 없거나 모듈로 2^N으로 정의된 오버플로가 필요한 경우가 아니면 `uint32_t`와 같은 부호 없는 정수 유형을 사용하면 안 됩니다.
특히 숫자가 절대 음수가 되지 않는다고 말하기 위해 부호 없는 유형을 사용하지 마십시오. 대신 이를 위해 어설션을 사용하십시오.

코드가 크기를 반환하는 컨테이너인 경우 컨테이너의 가능한 모든 용도를 수용할 유형을 사용해야 합니다. 확실하지 않은 경우 작은 유형보다 큰 유형을 사용하십시오.

정수 유형을 변환할 때 주의하십시오. 정수 변환 및 승격으로 인해 정의되지 않은 동작이 발생하여 보안 버그 및 기타 문제가 발생할 수 있습니다.

<a id="s8-12-64-bit-portability"></a>

### 8.12 64bit 이식성

코드는 64비트 및 32비트에 적합해야 합니다. 인쇄, 비교 및 구조 정렬 문제를 염두에 두십시오.

- 일부 통합 `typedef`에 대한 올바른 printf() 변환 지정자는 우리가 사용하기에 불쾌하고 요구하기에 비실용적이라고 생각하는 매크로 확장(<cinttypes>의 PRI 매크로)에 의존합니다.
  특정 사례에 대한 합리적인 대안이 없는 한 `printf` 계열에 의존하는 API를 피하거나 업그레이드하십시오. 대신 `StrCat` 또는 빠른 단순 변환을 위한 대체 또는 `std::ostream`과 같은
  형식이 안전한 숫자 형식을 지원하는 라이브러리를 사용하십시오.  <br><br>
  안타깝게도 PRI 매크로는 표준 비트폭 typedef(예: int64_t, uint64_t, int32_t, uint32_t 등)에 대한 변환을 지정하는 이식 가능한 유일한 방법입니다. 가능한 경우
  bitwidth typedefs로 지정된 유형의 인수를 printf 기반 API에 전달하지 마십시오. printf에 size_t(z), ptrdiff_t(t) 및 maxint_t(j)와 같은 전용 길이 수정자가
  있는 typedef를 사용할 수 있습니다.
- sizeof(void *) != sizeof(int)를 기억하십시오. 포인터 크기의 정수를 원하면 intptr_t를 사용하십시오.
- 특히 구조가 디스크에 저장되는 경우 구조 정렬에 주의해야 할 수 있습니다. int64_t/uint64_t 멤버가 있는 모든 클래스/구조는 기본적으로 64비트 시스템에서 8바이트로 정렬됩니다. 32비트와 64비트
  코드 간에 디스크에서 이러한 구조를 공유하는 경우 두 아키텍처에서 동일하게 패킹되도록 해야 합니다. 대부분의 컴파일러는 구조 정렬을 변경하는 방법을 제공합니다. gcc의 경우 __attribute__((
  packed))를 사용할 수 있습니다. MSVC는 #pragma pack() 및 __declspec(align())을 제공합니다.
- 64비트 상수를 생성하려면 필요에 따라 중괄호 초기화를 사용하십시오.
  ```cpp
  int64_t my_value{0x123456789};
  uint64_t my_mask{uint64_t{3} << 48};
  ```

<a id="s8-13-preprocessor-macros"></a>

### 8.13 전처리기 매크로

특히 헤더에서 매크로를 정의하지 마십시오. 인라인 함수, 열거형 및 const변수를 선호합니다.
프로젝트별 접두사를 사용하여 매크로 이름을 지정합니다. 매크로를 사용하여 C++ API의 일부를 정의하지 마십시오.

매크로는 당신이 보는 코드가 컴파일러가 보는 코드와 같지 않다는 것을 의미합니다.
특히 매크로에 전역 범위가 있기 때문에 이로 인해 예기치 않은 동작이 발생할 수 있습니다.

매크로로 인한 문제는 매크로가 C++ API의 일부를 정의하는 데 사용될 때 특히 심각하며 공개 API의 경우 더욱 그렇습니다.
개발자가 해당 인터페이스를 잘못 사용할 때 컴파일러의 모든 오류 메시지는 이제 매크로가 인터페이스를 형성한 방식을 설명해야 합니다.
리팩토링 및 분석 도구는 인터페이스를 업데이트하는 데 훨씬 더 많은 시간이 걸립니다.
결과적으로 우리는 이러한 방식으로 매크로를 사용하는 것을 특별히 허용하지 않습니다.
예를 들어 다음과 같은 패턴을 피하세요.

```cpp
class WOMBAT_TYPE(Foo) {
  // ...

 public:
  EXPAND_PUBLIC_WOMBAT_API(Foo)

  EXPAND_WOMBAT_COMPARISONS(Foo, ==, <)
};
```

운 좋게도 매크로는 C에서만큼 C++에서 거의 필요하지 않습니다. 매크로를 사용하여 성능이 중요한 코드를 인라인하는 대신 인라인 함수를 사용하십시오. 매크로를 사용하여 상수를 저장하는 대신 const 변수를
사용하십시오. 매크로를 사용하여 긴 변수 이름을 "축약"하는 대신 참조를 사용하십시오.

매크로는 이러한 다른 기술이 할 수 없는 일을 할 수 있으며 코드베이스, 특히 하위 수준 라이브러리에서 매크로를 볼 수 있습니다. 그리고 일부 특수 기능(문자열화, 연결 등)은 적절한 언어를 통해 사용할 수
없습니다. 그러나 매크로를 사용하기 전에 동일한 결과를 얻을 수 있는 매크로가 아닌 방법이 있는지 신중하게 고려하십시오. 매크로를 사용하여 인터페이스를 정의해야 하는 경우 프로젝트 리더에게 연락하여 이 규칙의 면제를
요청하십시오.

다음 사용 패턴은 매크로의 많은 문제를 방지합니다. 매크로를 사용하는 경우 가능할 때마다 매크로를 따르십시오.

- `.h` 파일에 매크로를 정의하지 마십시오.
- 매크로를 사용하기 직전에 `#define` 매크로를 사용하고 직후에 `#undef` 매크로를 사용하십시오.
- 자신의 것으로 바꾸기 전에 기존 매크로를 `#undef`하지 마십시오. 대신 고유할 가능성이 있는 이름을 선택하십시오.
- 균형이 맞지 않는 C++ 구성으로 확장되는 매크로를 사용하지 않거나 적어도 해당 동작을 잘 문서화하십시오.
- 함수/클래스/변수 이름을 생성하는 데 `##`을 사용하지 않는 것이 좋습니다.

헤더에서 매크로를 내보내는 것(즉, 헤더가 끝나기 전에 매크로를 `#undefing`하지 않고 헤더에서 정의하는 것)은 매우 권장되지 않습니다.
헤더에서 매크로를 내보내는 경우 전역적으로 고유한 이름이 있어야 합니다.
이를 위해서는 프로젝트의 네임스페이스 이름(단, 대문자)으로 구성된 접두사를 사용하여 이름을 지정해야 합니다.

<a id="s8-14-0-and-nullptr-null"></a>

### 8.14 0 및 nullptr/NULL

포인터에는 `nullptr`을 사용하고 문자에는 `'\0'`을 사용합니다(0 리터럴이 아님).

포인터(주소 값)의 경우 `type-safety`를 제공하는 `nullptr`을 사용하십시오.

`null` 문자에는 `'\0'`을 사용하십시오. 올바른 유형을 사용하면 코드를 더 쉽게 읽을 수 있습니다.

<a id="s8-15-sizeof"></a>

### 8.13 sizeof

sizeof(유형)보다 sizeof(varname)를 선호합니다.

특정 변수의 크기를 취할 때 sizeof(varname)를 사용하십시오.
sizeof(varname) 누군가 지금 또는 나중에 변수 유형을 변경하면 적절하게 업데이트됩니다.
적절한 C++ 유형의 변수가 편리하지 않은 외부 또는 내부 데이터 형식을 관리하는 코드와 같이 특정 변수와 관련되지 않은 코드에 sizeof(type)를 사용할 수 있습니다.

```cpp
MyStruct data;
memset(&data, 0, sizeof(data));
```

```cpp
memset(&data, 0, sizeof(MyStruct));
```

```cpp
if (raw_size < sizeof(int)) {
  LOG(ERROR) << "compressed record not big enough for count: " << raw_size;
  return false;
}
```

<a id="s8-16-type-deduction"></a>

### 8.16 유형공제(자동 포함)

유형 추론은 프로젝트에 익숙하지 않은 독자에게 코드를 더 명확하게 만들거나 코드를 더 안전하게 만드는 경우에만 사용하십시오. 명시적 형식을 작성하는 불편함을 피하기 위해서만 사용하지 마십시오.

정의:
C++에서 코드에 명시적으로 설명하지 않고 컴파일러에서 유형을 추론하도록 허용(또는 요구)하는 몇 가지 컨텍스트가 있습니다.

#### [Function template argument deduction](https://en.cppreference.com/w/cpp/language/template_argument_deduction)

명시적 템플릿 인수 없이 함수 템플릿을 호출할 수 있습니다. 컴파일러는 함수 인수 유형에서 해당 인수를 추론합니다.

```cpp
template <typename T>
void f(T t);

f(0);  // Invokes f<int>(0)
```

#### [auto variable declarations](https://en.cppreference.com/w/cpp/language/auto)

변수 선언은 유형 대신 auto 키워드를 사용할 수 있습니다. 컴파일러는 동일한 이니셜라이저를 사용하는 함수 템플릿 인수 추론과 동일한 규칙에 따라 변수의 이니셜라이저에서 유형을 추론합니다(괄호 대신 중괄호를
사용하지 않는 한).

```cpp
auto a = 42;  // a is an int
auto& b = a;  // b is an int&
auto c = b;   // c is an int
auto d{42};   // d is an int, not a std::initializer_list<int>
```

auto는 const로 한정될 수 있고 포인터 또는 참조 형식의 일부로 사용할 수 있지만 템플릿 인수로 사용할 수는 없습니다. 이 구문의 드문 변형은 auto 대신 decltype(auto)를 사용하는데, 이 경우
추론된 유형은 decltype을 이니셜라이저에 적용한 결과입니다.

#### [Function return type deduction](https://en.cppreference.com/w/cpp/language/function#Return_type_deduction)

auto(및 decltype(auto))는 함수 반환 유형 대신 사용할 수도 있습니다. 컴파일러는 변수 선언과 동일한 규칙에 따라 함수 본문의 return 문에서 반환 유형을 추론합니다.

```cpp
auto f() { return 0; }  // The return type of f is int
```

#### [Generic lambdas](https://isocpp.org/wiki/faq/cpp14-language#generic-lambdas)

람다 식은 하나 이상의 매개 변수 유형 대신 auto 키워드를 사용할 수 있습니다. 이로 인해 람다의 호출 연산자는 일반 함수가 아닌 함수 템플릿이 되며 각 auto 함수 매개 변수에 대해 별도의 템플릿 매개 변수가
있습니다.

```cpp
// Sort `vec` in decreasing order
std::sort(vec.begin(), vec.end(), [](auto lhs, auto rhs) { return lhs > rhs; });
```

#### [Lambda init captures](https://isocpp.org/wiki/faq/cpp14-language#lambda-captures)

Lambda 캡처에는 기존 변수만 캡처하는 것이 아니라 완전히 새로운 변수를 선언하는 데 사용할 수 있는 명시적 초기화 프로그램이 있을 수 있습니다.

```cpp
[x = 42, y = "foo"] { ... }  // x is an int, and y is a const char*
```

이 구문은 유형 지정을 허용하지 않습니다. 대신 자동 변수에 대한 규칙을 사용하여 추론됩니다.

#### [Class template argument deduction](https://en.cppreference.com/w/cpp/language/class_template_argument_deduction)

[아래](https://google.github.io/styleguide/cppguide.html#CTAD)를 참조하십시오.

#### [Structured bindings](https://en.cppreference.com/w/cpp/language/structured_binding)

auto를 사용하여 튜플, 구조체 또는 배열을 선언할 때 전체 개체의 이름 대신 개별 요소의 이름을 지정할 수 있습니다. 이러한 이름을 "구조적 바인딩"이라고 하며 전체 선언을 "구조적 바인딩 선언"이라고 합니다.
이 구문은 둘러싸는 객체 또는 개별 이름의 유형을 지정하는 방법을 제공하지 않습니다.

```cpp
auto [iter, success] = my_map.insert({key, value});
if (!success) {
  iter->second = value;
}
```

uto는 const, & 및 &&로 한정될 수도 있지만 이러한 한정자는 기술적으로 개별 바인딩이 아닌 익명 튜플/구조체/배열에 적용됩니다. 바인딩 유형을 결정하는 규칙은 매우 복잡합니다. 선언에서 참조를 선언하더라도
일반적으로 바인딩 유형이 참조가 아니라는 점을 제외하면 결과는 놀랍지 않은 경향이 있습니다(하지만 일반적으로 어쨌든 참조처럼 동작합니다).

장점:

- C++ 형식 이름은 특히 템플릿이나 네임스페이스와 관련된 경우 길고 번거로울 수 있습니다.
- C++ 형식 이름이 단일 선언 또는 작은 코드 영역 내에서 반복되는 경우 반복이 가독성에 도움이 되지 않을 수 있습니다.
- 의도하지 않은 복사 또는 유형 변환의 가능성을 피하기 때문에 유형을 추론하도록 하는 것이 때때로 더 안전합니다.

단점:  
C++ 코드는 일반적으로 유형이 명시적일 때, 특히 유형 추론이 코드의 먼 부분의 정보에 의존할 때 더 명확합니다.

```cpp
auto foo = x.add_foo();
auto i = y.Find(key);
```

y의 유형이 잘 알려지지 않았거나 y가 여러 줄 이전에 선언된 경우 결과 유형이 무엇인지 명확하지 않을 수 있습니다.

프로그래머는 유형 추론이 참조 유형을 생성하거나 생성하지 않을 때를 이해해야 합니다. 그렇지 않으면 의도하지 않은 복사본을 얻게 됩니다.

추론된 유형이 인터페이스의 일부로 사용되면 프로그래머가 값만 변경하려는 의도로 유형을 변경하여 의도한 것보다 더 급진적인 API 변경으로 이어질 수 있습니다.

결론:  
기본 규칙은 코드를 더 명확하고 안전하게 만들기 위해서만 유형 추론을 사용하고 명시적 유형을 작성하는 불편함을 피하기 위해 사용하지 않는 것입니다. 코드가 더 명확한지 판단할 때 독자가 반드시 팀에 있거나 프로젝트에
익숙하지 않을 수 있으므로 귀하와 귀하의 검토자가 불필요한 혼란으로 경험하는 유형은 다른 사람에게 유용한 정보를 제공하는 경우가 많습니다. 예를 들어, make_unique<Foo>()의 반환 유형은 명백하지만
MyWidgetFactory()의 반환 유형은 그렇지 않다고 가정할 수 있습니다.

<a id="s8-17-class-template-argument-deduction"></a>

### 8.17 템플릿 인자 추론

시적으로 지원하도록 선택한 템플릿에서만 클래스 템플릿 인수 추론을 사용합니다.

정의:  
클래스 템플릿 인수 추론(종종 "CTAD"로 축약됨)은 변수가 템플릿의 이름을 지정하는 유형으로 선언되고 템플릿 인수 목록이 제공되지 않을 때(빈 꺾쇠 괄호도 아님) 발생합니다.

```cpp
std::array a = {1, 2, 3};  // `a` is a std::array<int, 3>
```

컴파일러는 명시적이거나 암시적일 수 있는 템플릿의 "추론 가이드"를 사용하여 이니셜라이저에서 인수를 추론합니다.

명시적 추론 가이드는 앞에 auto가 없고 함수 이름이 템플릿의 이름이라는 점을 제외하면 후행 반환 유형이 있는 함수 선언처럼 보입니다. 예를 들어, 위의 예는 std::array에 대한 이 추론 가이드에
의존합니다.

```cpp
namespace std {
template <class T, class... U>
array(T, U...) -> std::array<T, 1 + sizeof...(U)>;
}
```

기본 템플릿의 생성자(템플릿 특수화와 반대)도 추론 가이드를 암시적으로 정의합니다.

CTAD에 의존하는 변수를 선언하면 컴파일러는 생성자 오버로드 해결 규칙을 사용하여 추론 가이드를 선택하고 해당 가이드의 반환 유형이 변수의 유형이 됩니다.

장점:  
CTAD를 사용하면 코드에서 상용구를 생략할 수 있습니다.

단점:  
생성자에서 생성된 암시적 추론 가이드는 바람직하지 않은 동작을 하거나 완전히 올바르지 않을 수 있습니다. 이것은 CTAD가 C++17에 도입되기 전에 작성된 생성자의 경우 특히 문제가 됩니다. 해당 생성자의 작성자는
해당 생성자가 CTAD에 대해 야기할 수 있는 문제를 알 방법이 없었기 때문입니다. 또한 이러한 문제를 해결하기 위해 명시적 추론 가이드를 추가하면 암시적 추론 가이드에 의존하는 기존 코드가 손상될 수 있습니다.

CTAD는 또한 auto와 동일한 많은 단점이 있습니다. 두 가지 모두 초기화 프로그램에서 변수 유형의 전체 또는 일부를 추론하는 메커니즘이기 때문입니다. CTAD는 독자에게 자동보다 더 많은 정보를 제공하지만
독자에게 정보가 생략되었다는 명백한 단서를 제공하지도 않습니다.

결론:  
템플릿의 관리자가 최소한 하나의 명시적 추론 가이드를 제공하여 CTAD 사용 지원을 선택하지 않은 경우 지정된 템플릿과 함께 CTAD를 사용하지 마십시오(std 네임스페이스의 모든 템플릿도 선택한 것으로 추정됨).
가능한 경우 컴파일러 경고와 함께 이를 시행해야 합니다.

CTAD의 사용은 또한 유형 공제에 대한 일반 규칙을 따라야 합니다.

<a id="s8-18-designated-initializers"></a>

### 8.18 지정된 이니셜라이저

지정된 이니셜라이저는 C++20 호환 형식으로만 사용하십시오.

정의:  
[지정된 이니셜라이저](https://en.cppreference.com/w/cpp/language/aggregate_initialization#Designated_initializers)는 필드의 이름을 명시적으로
지정하여 집계("일반 이전 구조체")를 초기화할 수 있는 구문입니다.

```cpp
  struct Point { 
    float x = 0.0; 
    플로트 y = 0.0; 
    플로트 z = 0.0; 
  }; 

  점 p = { 
    .x = 1.0, 
    .y = 2.0, 
    // z는 0.0이 됩니다. 
  };
```

명시적으로 나열된 필드는 지정된 대로 초기화되며 다른 필드는 와 같은 기존 집계 초기화 표현식에서와 동일한 방식으로 초기화됩니다 Point{1.0, 2.0}.

장점:  
지정된 이니셜라이저는 특히 위의 Point 예제보다 덜 간단한 필드 순서가 있는 구조체의 경우 편리하고 읽기 쉬운 집계 식을 만들 수 있습니다.

단점:  
지정된 이니셜라이저는 오랫동안 C 표준의 일부였으며 C++ 컴파일러에서 확장으로 지원했지만 최근에야 C++ 표준으로 만들어 C++20의 일부로 추가되었습니다.

C++ 표준의 규칙은 C 및 컴파일러 확장에서보다 엄격하므로 지정된 이니셜라이저가 구조체 정의에 나타나는 필드와 동일한 순서로 나타나야 합니다. 따라서 위의 예에서 C++20에 따라 x와 z를 초기화하는 것은
합법적이지만 y와 x는 초기화할 수 없습니다.

결론:  
지정된 이니셜라이저는 C++20 표준과 호환되는 형식으로만 사용하세요. 이니셜라이저는 해당 필드가 구조체 정의에 나타나는 순서와 동일합니다.

<a id="s8-19-lambda-expressions"></a>

### 8.19 람다 표현식

적절한 경우 람다 식을 사용하십시오. 람다가 현재 범위를 벗어날 때 명시적 캡처를 선호합니다

정의:  
람다 식은 익명 함수 개체를 만드는 간결한 방법입니다. 함수를 인수로 전달할 때 종종 유용합니다.

```cpp
std::sort(v.begin(), v.end(), [](int x, int y) {
  return Weight(x) < Weight(y);
});
```

또한 이름으로 명시적으로 또는 기본 캡처를 사용하여 암시적으로 둘러싸는 범위에서 변수를 캡처할 수 있습니다. 명시적 캡처에는 각 변수가 값 또는 참조 캡처로 나열되어야 합니다.

```cpp
int weight = 3;
int sum = 0;
// Captures `weight` by value and `sum` by reference.
std::for_each(v.begin(), v.end(), [weight, &sum](int x) {
  sum += weight * x;
});
```

기본 캡처는 멤버가 사용되는 경우를 포함하여 람다 본문에서 참조되는 모든 변수를 암시적으로 캡처합니다.

```cpp
const std::vector<int> lookup_table = ...;
std::vector<int> indices = ...;
// Captures `lookup_table` by reference, sorts `indices` by the value
// of the associated element in `lookup_table`.
std::sort(indices.begin(), indices.end(), [&](int a, int b) {
  return lookup_table[a] < lookup_table[b];
});
```

수 캡처에는 값으로 이동 전용 변수를 캡처하거나 일반 참조 또는 값 캡처로 처리되지 않는 다른 상황에 사용할 수 있는 명시적 초기화 프로그램이 있을 수 있습니다.

```cpp
std::unique_ptr<Foo> foo = ...;
[foo = std::move(foo)] () {
  ...
}
```

이러한 캡처(종종 "초기화 캡처" 또는 "일반화된 람다 캡처"라고 함)는 실제로 둘러싸는 범위에서 어떤 것도 "캡처"할 필요가 없으며 심지어 둘러싸는 범위에서 이름을 가질 필요도 없습니다. 이 구문은 람다 객체의
멤버를 정의하는 완전히 일반적인 방법입니다.

```cpp
[foo = std::vector<int>({1, 2, 3})] () {
  ...
}
```

이니셜라이저가 있는 캡처 유형은 자동과 동일한 규칙을 사용하여 추론됩니다.

장점:

- 람다는 STL 알고리즘에 전달할 함수 개체를 정의하는 다른 방법보다 훨씬 더 간결하므로 가독성이 향상될 수 있습니다.
- 기본 캡처를 적절하게 사용하면 중복을 제거하고 기본에서 중요한 예외를 강조 표시할 수 있습니다.
- Lambdas, std::function 및 std::bind는 범용 콜백 메커니즘으로 조합하여 사용할 수 있습니다. 바인딩된 함수를 인수로 사용하는 함수를 쉽게 작성할 수 있습니다.

단점:

- 람다의 변수 캡처는 특히 람다가 현재 범위를 벗어나는 경우 댕글링 포인터 버그의 원인이 될 수 있습니다.
- 값에 의한 기본 캡처는 현수 포인터 버그를 방지하지 않기 때문에 오해의 소지가 있습니다. 포인터를 값으로 캡처해도 깊은 복사가 발생하지 않으므로 참조로 캡처할 때와 동일한 수명 문제가 있는 경우가 많습니다.
  this의 사용이 암시적인 경우가 많기 때문에 this를 값으로 캡처할 때 특히 혼란스럽습니다.
- 캡처는 실제로 새 변수를 선언하지만(캡처에 이니셜라이저가 있는지 여부에 관계없이) C++의 다른 변수 선언 구문과 전혀 다릅니다. 특히, 변수의 유형이나 자동 자리 표시자를 위한 자리가 없습니다(비록 초기화
  캡처가 예를 들어 캐스트를 사용하여 간접적으로 나타낼 수 있음). 이로 인해 선언으로 인식하기조차 어려울 수 있습니다.
- Init 캡처는 본질적으로 유형 추론에 의존하며 자동과 동일한 많은 단점이 있으며 구문이 독자에게 추론이 발생하고 있다는 신호조차 주지 않는다는 추가 문제가 있습니다.
- 람다를 사용할 수 없는 경우가 있습니다. 매우 긴 중첩 익명 함수는 코드를 이해하기 어렵게 만들 수 있습니다.

결론:

- 적절한 경우 람다 식을 사용하십시오.
- 람다가 현재 범위를 벗어날 수 있는 경우 명시적 캡처를 선호합니다

```cpp
{
  Foo foo;
  ...
  executor->Schedule([&] { Frobnicate(foo); })
  ...
}
// BAD! The fact that the lambda makes use of a reference to `foo` and
// possibly `this` (if `Frobnicate` is a member function) may not be
// apparent on a cursory inspection. If the lambda is invoked after
// the function returns, that would be bad, because both `foo`
// and the enclosing object could have been destroyed.
```

다음과 같이 작성하는 것을 선호합니다.

```cpp
{
  Foo foo;
  ...
  executor->Schedule([&foo] { Frobnicate(foo); })
  ...
}
// BETTER - The compile will fail if `Frobnicate` is a member
// function, and it's clearer that `foo` is dangerously captured by
// reference.
```

- 참조에 의한 기본 캡처([&])는 람다의 수명이 잠재적인 캡처보다 확실히 짧은 경우에만 사용하십시오.
- 값으로 기본 캡처([=])를 짧은 람다에 대한 몇 가지 변수를 바인딩하는 수단으로만 사용하십시오. 여기에서 캡처된 변수 세트는 한눈에 명확하고 이를 암시적으로 캡처하지 않습니다. (즉, 비정적 클래스 멤버 함수에
  나타나고 본문에서 비정적 클래스 멤버를 참조하는 람다는 이를 명시적으로 또는 [&]를 통해 캡처해야 합니다.) 기본 캡처로 길거나 복잡한 람다를 작성하지 않는 것이 좋습니다. 값.
- 둘러싸는 범위에서 변수를 실제로 캡처하는 경우에만 캡처를 사용하십시오. 새 이름을 도입하거나 기존 이름의 의미를 크게 변경하기 위해 이니셜라이저와 함께 캡처를 사용하지 마십시오. 대신 기존 방식으로 새 변수를
  선언한 다음 캡처하거나 람다 속기를 피하고 함수 개체를 명시적으로 정의합니다.
- 매개변수 및 반환 유형 지정에 대한 지침은 유형 공제 섹션을 참조하세요.

<a id="s8-20-template-metaprogramming"></a>

### 8.20 템플릿 메타프로그래밍

복잡한 템플릿 프로그래밍을 피하십시오.

정의:  
템플릿 메타프로그래밍은 C++ 템플릿 인스턴스화 메커니즘이 튜링 완전하고 유형 도메인에서 임의의 컴파일 시간 계산을 수행하는 데 사용할 수 있다는 사실을 이용하는 기술 계열을 말합니다.

장점:  
템플릿 메타프로그래밍은 형식이 안전하고 고성능인 매우 유연한 인터페이스를 허용합니다.

단점:  
템플릿 메타프로그래밍에 사용되는 기술은 언어 전문가 외에는 누구에게나 모호한 경우가 많습니다. 복잡한 방식으로 템플릿을 사용하는 코드는 종종 읽을 수 없으며 디버그하거나 유지 관리하기 어렵습니다.

템플릿 메타프로그래밍은 종종 매우 형편없는 컴파일 시간 오류 메시지로 이어집니다. 인터페이스가 단순하더라도 사용자가 무언가 잘못하면 복잡한 구현 세부 정보가 표시됩니다.

템플릿 메타프로그래밍은 리팩토링 도구의 작업을 더 어렵게 만들어 대규모 리팩토링을 방해합니다. 첫째, 템플릿 코드는 여러 컨텍스트에서 확장되며 모든 컨텍스트에서 변환이 의미가 있는지 확인하기 어렵습니다. 둘째, 일부
리팩토링 도구는 템플릿 확장 후 코드 구조만 나타내는 AST와 함께 작동합니다. 다시 작성해야 하는 원래 소스 구성으로 자동으로 다시 작업하는 것은 어려울 수 있습니다.

결론:  
템플릿 메타프로그래밍은 때때로 그것 없이 가능한 것보다 더 깨끗하고 사용하기 쉬운 인터페이스를 허용하지만, 종종 지나치게 영리해지고 싶은 유혹을 받기도 합니다. 추가 유지 관리 부담이 많은 용도로 분산되는 소수의
저수준 구성 요소에 가장 적합합니다.

템플릿 메타 프로그래밍 또는 기타 복잡한 템플릿 기술을 사용하기 전에 두 번 생각하십시오. 팀의 일반 구성원이 다른 프로젝트로 전환한 후에도 코드를 유지 관리할 수 있을 만큼 충분히 잘 이해할 수 있는지 또는 C++
프로그래머가 아니거나 코드 베이스를 우연히 탐색하는 사람이 오류 메시지를 이해할 수 있는지 생각해 보십시오. 또는 호출하려는 함수의 흐름을 추적합니다. 재귀 템플릿 인스턴스화, 유형 목록, 메타 함수 또는 식
템플릿을 사용하거나 SFINAE 또는 함수 오버로드 해결을 감지하는 트릭에 의존하는 sizeof경우 너무 멀리 갔을 가능성이 큽니다.

템플릿 메타프로그래밍을 사용하는 경우 복잡성을 최소화하고 격리하는 데 상당한 노력을 기울여야 합니다. 가능하면 구현 세부 사항으로 메타프로그래밍을 숨겨서 사용자에게 표시되는 헤더를 읽을 수 있도록 해야 하며 까다로운
코드에 특히 주석이 잘 달려 있는지 확인해야 합니다. 코드가 어떻게 사용되는지 주의 깊게 문서화해야 하며 "생성된" 코드가 어떻게 생겼는지에 대해 설명해야 합니다. 사용자가 실수할 때 컴파일러가 내보내는 오류
메시지에 각별히 주의하십시오. 오류 메시지는 사용자 인터페이스의 일부이며 사용자 관점에서 오류 메시지를 이해하고 실행할 수 있도록 필요에 따라 코드를 수정해야 합니다.

<a id="s8-21-boost"></a>

### 8.21 boost

<a id="s8-22-orther-c++-features"></a>

### 8.22 기타 C++ 기능

<a id="s8-23-nonstandard-extensions"></a>

### 8.23 비표준 확장

C++에 대한 비표준 확장은 별도로 지정하지 않는 한 사용할 수 없습니다.

정의:  
컴파일러는 표준 C++의 일부가 아닌 다양한 확장을 지원합니다.

장점:

- 비표준 확장은 표준 C++에 없는 유용한 기능을 제공할 수 있습니다.
- 컴파일러에 대한 중요한 성능 지침은 확장을 통해서만 지정할 수 있습니다.

단점:

- 비표준 확장은 모든 컴파일러에서 작동하지 않습니다. 비표준 확장을 사용하면 코드 이식성이 감소합니다.
- 모든 대상 컴파일러에서 지원되더라도 확장이 잘 지정되지 않은 경우가 많으며 컴파일러 간에 미묘한 동작 차이가 있을 수 있습니다.
- 비표준 확장은 독자가 코드를 이해하기 위해 알아야 하는 언어 기능을 추가합니다.
- 비표준 확장은 아키텍처 간 포팅을 위한 추가 작업이 필요합니다.

결론:  
비표준 확장을 사용하지 마십시오. 해당 래퍼가 지정된 프로젝트 전체 이식성 헤더에서 제공되는 한 비표준 확장을 사용하여 구현된 이식성 래퍼를 사용할 수 있습니다.

<a id="s8-24-aliases"></a>

### 8.24 별칭

공용 별칭은 API 사용자를 위한 것이며 명확하게 문서화되어야 합니다.

정의:  
다른 엔터티의 별칭인 이름을 만드는 방법에는 여러 가지가 있습니다.

```cpp
typedef Foo Bar;
using Bar = Foo;
using other_namespace::Foo;
```

새 코드에서는 typedef보다 using을 사용하는 것이 좋습니다. C++의 나머지 부분과 더 일관된 구문을 제공하고 템플릿과 함께 작동하기 때문입니다.

다른 선언과 마찬가지로 헤더 파일에서 선언된 별칭은 함수 정의, 클래스의 전용 부분 또는 명시적으로 표시된 내부 네임스페이스에 있지 않는 한 해당 헤더의 공용 API의 일부입니다. 이러한 영역 또는 .cc 파일의
별칭은 구현 세부 정보이며(클라이언트 코드에서 참조할 수 없기 때문에) 이 규칙에 의해 제한되지 않습니다.

장점:

- 별칭은 길거나 복잡한 이름을 단순화하여 가독성을 향상시킬 수 있습니다.
- 별칭은 API에서 반복적으로 사용되는 유형의 이름을 한 곳에서 지정하여 중복을 줄일 수 있으므로 나중에 유형을 더 쉽게 변경할 수 있습니다.

단점:

- 클라이언트 코드가 참조할 수 있는 헤더에 배치될 때 별칭은 해당 헤더의 API에 있는 엔터티 수를 증가시켜 복잡성을 증가시킵니다.
- 클라이언트는 공개 별칭의 의도하지 않은 세부 정보에 쉽게 의존할 수 있으므로 변경이 어렵습니다.
- API 또는 유지 관리 가능성에 미치는 영향을 고려하지 않고 구현에만 사용할 공용 별칭을 만들고 싶을 수 있습니다.
- 별칭은 이름 충돌의 위험을 초래할 수 있습니다.
- 별칭은 친숙한 구성에 익숙하지 않은 이름을 부여하여 가독성을 떨어뜨릴 수 있습니다.
- 유형 별칭은 불명확한 API 계약을 생성할 수 있습니다. 별칭이 별칭이 지정하는 유형과 동일한지, 동일한 API를 갖는지 또는 지정된 좁은 방식으로만 사용할 수 있는지가 확실하지 않습니다.

결론:  
구현에서 입력을 저장하기 위해 공용 API에 별칭을 넣지 마십시오. 고객이 사용하려는 경우에만 그렇게 하십시오.

공용 별칭을 정의할 때 현재 별칭이 지정된 유형과 항상 동일한지 여부 또는 보다 제한된 호환성을 의도하는지 여부를 포함하여 새 이름의 의도를 문서화합니다. 이를 통해 사용자는 유형을 대체 가능한 것으로 처리할 수
있는지 또는 보다 구체적인 규칙을 따라야 하는지 여부를 알 수 있으며 구현에서 별칭을 변경할 수 있는 어느 정도의 자유를 유지할 수 있습니다.

```cpp
namespace mynamespace {
// Used to store field measurements. DataPoint may change from Bar* to some internal type.
// Client code should treat it as an opaque pointer.
using DataPoint = ::foo::Bar*;

// A set of measurements. Just an alias for user convenience.
using TimeSeries = std::unordered_set<DataPoint, std::hash<DataPoint>, DataPointComparator>;
}  // namespace mynamespace
```

이러한 별칭은 의도된 용도를 문서화하지 않으며 그 중 절반은 클라이언트용이 아닙니다.

```cpp
namespace mynamespace {
// Bad: none of these say how they should be used.
using DataPoint = ::foo::Bar*;
using ::std::unordered_set;  // Bad: just for local convenience
using ::std::hash;           // Bad: just for local convenience
typedef unordered_set<DataPoint, hash<DataPoint>, DataPointComparator> TimeSeries;
}  // namespace mynamespace\
```

그러나 로컬 편의 별칭은 함수 정의, 클래스의 전용 섹션, 명시적으로 표시된 내부 네임스페이스 및 .cc 파일에서 괜찮습니다.

```cpp
// In a .cc file
using ::foo::Bar;
```

<a id="s8-25-switch-statements"></a>

### 8.25 Switch 문장

열거된 값에 대한 조건이 아닌 경우 switch 문에는 항상 기본 케이스가 있어야 합니다(열거된 값의 경우 처리되지 않은 값이 있으면 컴파일러에서 경고함). 기본 사례가 실행되지 않아야 하는 경우 이를 오류로
처리합니다

```cpp
switch (var) {
  case 0: {
    ...
    break;
  }
  case 1: {
    ...
    break;
  }
  default: {
    LOG(FATAL) << "Invalid value in switch statement: " << var;
  }
```

한 케이스 레이블에서 다른 케이스 레이블로 넘어가는 경우 [[fallthrough]]를 사용하여 주석을 달아야 합니다. 기인하다. [[실패로 끝나다]]; 다음 케이스 레이블에 대한 폴스루가 발생하는 실행 지점에
배치해야 합니다. 일반적인 예외는 개입 코드가 없는 연속적인 케이스 레이블이며, 이 경우에는 주석이 필요하지 않습니다.

```cpp
switch (x) {
  case 41:  // No annotation needed here.
  case 43:
    if (dont_be_picky) {
      // Use this instead of or along with annotations in comments.
      [[fallthrough]];
    } else {
      CloseButNoCigar();
      break;
    }
  case 42:
    DoSomethingSpecial();
    [[fallthrough]];
  default:
    DoSomethingGeneric();
    break;
}
```

<a id="s9-inclusive-language"></a>

## 9 포괄적인 언어

명명 및 주석을 포함한 모든 코드에서 포괄적인 언어를 사용하고 다른 프로그래머가 무례하거나 공격적이라고 생각할 수 있는 용어(예: "마스터" 및 "슬레이브", "블랙리스트" 및 "화이트리스트" 또는 "레드라인")를
피하십시오. 이 용어는 또한 표면적으로 중립적인 의미를 갖습니다. 마찬가지로, 특정 사람을 언급(및 대명사 사용)하지 않는 한 성중립적인 언어를 사용하세요. 예를 들어 성별이 불분명한 사람에게는 "they"/"
them"/"their"를 사용하고(단수인 경우에도) 소프트웨어, 컴퓨터 및 사람이 아닌 다른 대상에는 "it"/"its"를 사용합니다.

<a id="10-naming"></a>

## 10 네이밍

가장 중요한 일관성 규칙은 명명 규칙입니다. 이름의 스타일은 해당 엔터티의 선언을 검색할 필요 없이 명명된 엔터티가 유형, 변수, 함수, 상수, 매크로 등 어떤 종류인지 즉시 알려줍니다. 우리 두뇌의 패턴 일치
엔진은 이러한 명명 규칙에 크게 의존합니다.

이름 지정 규칙은 매우 임의적이지만 이 영역에서 개인의 선호도보다 일관성이 더 중요하다고 생각합니다.

<a id="s10-1-general-naming-rules"></a>

### 10.1 일반 명명 규칙

다른 팀의 사람들에게도 명확한 이름을 사용하여 가독성을 최적화합니다.

개체의 목적이나 의도를 설명하는 이름을 사용합니다. 새로운 독자가 코드를 즉시 이해할 수 있도록 만드는 것이 훨씬 더 중요하므로 가로 공간 절약에 대해 걱정하지 마십시오. 프로젝트 외부의 누군가에게 알려지지 않은
약어(특히 두문자어 및 머리글자)의 사용을 최소화합니다. 단어 내에서 문자를 삭제하여 약어를 작성하지 마십시오. 일반적으로 Wikipedia에 나열된 약어는 괜찮을 것입니다. 일반적으로 설명력은 이름의 가시성 범위에
비례해야 합니다. 예를 들어, n5줄 함수 내에서는 괜찮은 이름일 수 있지만 클래스 범위 내에서는 너무 모호할 수 있습니다.

```cpp
class MyClass {
 public:
  int CountFooErrors(const std::vector<Foo>& foos) {
    int n = 0;  // Clear meaning given limited scope and context
    for (const auto& foo : foos) {
      ...
      ++n;
    }
    return n;
  }
  void DoSomethingImportant() {
    std::string fqdn = ...;  // Well-known abbreviation for Fully Qualified Domain Name
  }
 private:
  const int kMaxAllowedConnections = ...;  // Clear meaning within context
};
```

```cpp
class MyClass {
 public:
  int CountFooErrors(const std::vector<Foo>& foos) {
    int total_number_of_foo_errors = 0;  // Overly verbose given limited scope and context
    for (int foo_index = 0; foo_index < foos.size(); ++foo_index) {  // Use idiomatic `i`
      ...
      ++total_number_of_foo_errors;
    }
    return total_number_of_foo_errors;
  }
  void DoSomethingImportant() {
    int cstmr_id = ...;  // Deletes internal letters
  }
 private:
  const int kNum = ...;  // Unclear meaning within broad scope
};
```

반복 변수의 경우 i, 템플릿 매개변수의 경우 T와 같이 보편적으로 알려진 특정 약어는 괜찮습니다.

아래 명명 규칙의 목적상 "단어"는 내부 공백 없이 영어로 작성하는 모든 것을 의미합니다. 여기에는 두문자어 및 두문자어와 같은 약어가 포함됩니다.
각 단어의 첫 글자가 대문자인 혼합 대소문자(때때로 "카멜 표기" 또는 "파스칼 표기"라고도 함)로 작성된 이름의 경우 약어를 한 단어로 대문자로 표기하는 것을 선호합니다(예: StartRPC보다는
StartRpc())

<a id="s10-2-file-names"></a>

### 10.2 파일 이름

파일 이름은 모두 소문자여야 하며 밑줄(_) 또는 대시(-)를 포함할 수 있습니다. 프로젝트에서 사용하는 규칙을 따르

허용되는 파일 이름의 예:

- my_useful_class.cc
- my-useful-class.cc
- myusefulclass.cc
- myusefulclass_test.cc

C++ 파일은 .cc로 끝나야 하고 헤더 파일은 .h로 끝나야 합니다. 특정 지점에 텍스트로 포함되는 파일은 .inc로 끝나야 합니다(자체 포함 헤더 섹션 참조).

db.h와 같이 /usr/include에 이미 존재하는 파일 이름을 사용하지 마십시오.

일반적으로 파일 이름을 매우 구체적으로 지정하십시오. 예를 들어, logs.h 대신 http_server_logs.h를 사용하십시오. 매우 일반적인 경우는 FooBar라는 클래스를 정의하는 foo_bar.h 및
foo_bar.cc라는 파일 쌍을 갖는 것입니다.

<a id="s10-3-type-names"></a>

### 10.3 타입 이름

유형 이름은 대문자로 시작하고 새 단어마다 대문자를 사용하며 밑줄은 없습니다: MyExcitingClass, MyExcitingEnum.

클래스, 구조체, 유형 별칭, 열거형 및 유형 템플릿 매개 변수와 같은 모든 유형의 이름은 동일한 명명 규칙을 갖습니다. 유형 이름은 대문자로 시작해야 하며 새 단어마다 대문자가 있어야 합니다. 밑줄이 없습니다.

```cpp
// classes and structs
class UrlTable { ...
class UrlTableTester { ...
struct UrlTableProperties { ...

// typedefs
typedef hash_map<UrlTableProperties *, std::string> PropertiesMap;

// using aliases
using PropertiesMap = hash_map<UrlTableProperties *, std::string>;

// enums
enum class UrlTableError { ...
```

<a id="s10-4-variable-names"></a>

### 10.4 변수 이름

변수(함수 매개변수 포함) 및 데이터 멤버의 이름은 모두 소문자이며 단어 사이에 밑줄이 있습니다. 클래스의 데이터 멤버(구조체 제외)에는 추가로 후행 밑줄이 있습니다

예 :  a_local_variable, a_struct_data_member, a_class_data_member_

<a id="s10-4-1-common-variable-names"></a>

#### 10.4.1 일반 변수 이름

예:

```cpp
std::string table_name;  // OK - lowercase with underscore.
```

```cpp
std::string tableName;   // Bad - mixed case.
```

<a id="s10-4-2-class-data-members"></a>

#### 10.4.2 클래스 멤버 이름

정적 및 비정적 클래스의 데이터 멤버는 일반적인 비멤버 변수처럼 이름이 지정되지만 뒤에 밑줄이 붙습니다.

```cpp
class TableInfo {
  ...
 private:
  std::string table_name_;  // OK - underscore at end.
  static Pool<TableInfo>* pool_;  // OK.
};
```

<a id="s10-4-3-struct-data-members"></a>

#### 10.4.3 구조체 멤버 이름

정적 및 비정적 구조체의 데이터 멤버는 일반 비멤버 변수와 같이 이름이 지정됩니다. 클래스의 데이터 멤버에 있는 후행 밑줄이 없습니다.

```cpp
struct UrlTableProperties {
  std::string name;
  int num_entries;
  static Pool<UrlTableProperties>* pool;
};
```

<a id="s10-5-constant-names"></a>

### 10.5 상수 이름

constexpr 또는 const로 선언되고 프로그램 기간 동안 값이 고정되는 변수는 앞에 "k"가 붙고 그 뒤에 대소문자가 혼합되어 이름이 지정됩니다. 대문자를 구분에 사용할 수 없는 드문 경우에 밑줄을 구분
기호로 사용할 수 있습니다.

```cpp
const int kDaysInAWeek = 7;
const int kAndroid8_0_0 = 24;  // Android 8.0.0
```

정적 저장 기간(예: 정적 및 전역, 자세한 내용은 저장 기간 참조)이 있는 이러한 모든 변수는 이러한 방식으로 이름을 지정해야 합니다. 이 규칙은 다른 스토리지 클래스의 변수(예: 자동 변수)에 대해 선택
사항입니다. 그렇지 않으면 일반적인 변수 명명 규칙이 적용됩니다.

<a id="s10-6-function-names"></a>

### 10.6 함수 이름

일반 함수에는 대소문자가 혼합되어 있습니다. 접근자와 뮤테이터는 변수처럼 이름이 지정될 수 있습니다.

일반적으로 함수는 대문자로 시작해야 하며 새 단어마다 대문자가 있어야 합니다.

```cpp
AddTableEntry() 
DeleteUrl() 
OpenFileOrDie()
```

(동일한 이름 지정 규칙이 API의 일부로 노출되고 함수처럼 보이도록 의도된 클래스 및 네임스페이스 범위 상수에 적용됩니다. 함수가 아니라 객체라는 사실은 중요하지 않은 구현 세부 사항이기 때문입니다.

접근자와 뮤테이터(get 및 set 함수)는 변수처럼 이름을 지정할 수 있습니다. 이는 종종 실제 멤버 변수에 해당하지만 필수는 아닙니다.

<a id="s10-7-namespace-names"></a>

### 10.7 네임스페이스 이름

네임스페이스 이름은 모두 소문자이며 단어는 밑줄로 구분됩니다. 최상위 네임스페이스 이름은 프로젝트 이름을 기반으로 합니다. 중첩된 네임스페이스와 잘 알려진 최상위 네임스페이스 간의 충돌을 피하십시오.

최상위 네임스페이스의 이름은 일반적으로 해당 네임스페이스에 코드가 포함된 프로젝트 또는 팀의 이름이어야 합니다. 해당 네임스페이스의 코드는 일반적으로 기본 이름이 네임스페이스 이름과 일치하는 디렉터리(또는 해당 하위
디렉터리)에 있어야 합니다.

축약된 이름에 대한 규칙은 변수 이름만큼 네임스페이스에도 적용된다는 점을 명심하십시오 . 네임스페이스 내부의 코드는 네임스페이스 이름을 거의 언급할 필요가 없으므로 일반적으로 약어가 특별히 필요하지 않습니다.

잘 알려진 최상위 네임스페이스와 일치하는 중첩된 네임스페이스를 사용하지 마십시오. 네임스페이스 이름 간의 충돌은 이름 조회 규칙으로 인해 놀라운 빌드 중단으로 이어질 수 있습니다. 특히 중첩된 std네임스페이스를
만들지 마십시오

네임스페이스 의 경우 충돌을 일으키는 internal동일한 네임스페이스에 다른 코드가 추가되는 것을 주의하십시오

<a id="s10-8-enumerator-names"></a>

### 10.8 열거자 이름

열거자(범위가 지정된 열거형과 범위가 지정되지 않은 열거형 모두)는 매크로가 아닌 상수처럼 이름을 지정해야 합니다. 즉, ENUM_NAME이 아닌 kEnumName을 사용하십시오.

```cpp
enum class UrlTableError {
  kOk = 0,
  kOutOfMemory,
  kMalformedInput,
};
```

```cpp
enum class AlternateUrlTableError {
  OK = 0,
  OUT_OF_MEMORY = 1,
  MALFORMED_INPUT = 2,
}
```

2009년 1월까지 스타일은 매크로처럼 enum 값의 이름을 지정하는 것이었습니다. 이로 인해 enum 값과 매크로 간의 이름 충돌 문제가 발생했습니다. 따라서 상수 스타일 이름 지정을 선호하도록 변경되었습니다.
새 코드는 상수 스타일 이름 지정을 사용해야 합니다.

<a id="s10-9-macro-names"></a>

### 10.9 매크로 이름

실제로 매크로를 정의하지 않을 건가요? 그렇게 하면 MY_MACRO_THAT_SCARES_SMALL_CHILDREN_AND_ADULTS_ALIKE와 같습니다.

매크로 설명을 참조하십시오. 일반적으로 매크로는 사용하면 안 됩니다. 그러나 반드시 필요한 경우 모두 대문자와 밑줄로 이름을 지정하고 프로젝트별 접두사를 붙여야 합니다.

```cpp
#define MYPROJECT_ROUND(x) ...
```

<a id="s10-10-exceptions-to-namaing-rules"></a>

### 10.10 예외 이름 규칙

기존 C 또는 C++ 엔터티와 유사한 이름을 지정하는 경우 기존 명명 규칙 체계를 따를 수 있습니다.

```cpp
bigopen()
    function name, follows form of open()
uint
    typedef
bigpos
    struct or class, follows form of pos
sparse_hash_map
    STL-like entity; follows STL naming conventions
LONGLONG_MAX
    a constant, as in INT_MAX
```

<a id="s11-comments"></a>

## 11 주석

주석은 코드를 읽기 쉽게 유지하는 데 절대적으로 중요합니다. 다음 규칙은 주석을 달아야 하는 내용과 위치를 설명합니다. 하지만 기억하세요. 주석이 매우 중요하지만 최고의 코드는 자체 문서화입니다. 유형과 변수에 의미
있는 이름을 지정하는 것이 주석을 통해 설명해야 하는 모호한 이름을 사용하는 것보다 훨씬 낫습니다.
의견을 작성할 때 청중, 즉 코드를 이해해야 하는 다음 기여자를 위해 작성하십시오

<a id="s11-1-comment-style"></a>

### 11.1 주석 스타일

일관성이 있는 한 //또는 구문을 사용하십시오 ./* */

//또는 구문을 사용할 수 있습니다 /* */. 그러나 훨씬 더 일반적 //입니다 . 주석을 작성하는 방법과 사용하는 스타일에 일관성을 유지하세요.

<a id="s11-2-file-comments"></a>

### 11.2 파일 주석

라이선스 상용구로 각 파일을 시작합니다.

파일 주석은 파일의 내용을 설명합니다. 파일이 선언 시점에 주석으로 문서화된 정확히 하나의 추상화를 선언, 구현 또는 테스트하는 경우 파일 주석이 필요하지 않습니다. 다른 모든 파일에는 파일 주석이 있어야 합니다.

<a id="s11-2-1-legal-notice-and-author-line"></a>

#### 11.2.1 법적 고지 및 작성자 라인

모든 파일에는 라이선스 상용구가 포함되어야 합니다. 프로젝트에서 사용하는 라이선스에 적합한 상용구를 선택합니다(예: Apache 2.0, BSD, LGPL, GPL).

작성자 라인이 있는 파일을 크게 변경하는 경우 작성자 라인을 삭제하는 것이 좋습니다. 새 파일에는 일반적으로 저작권 표시나 저자 표시가 없어야 합니다.

<a id="s11-2-2-file-contents"></a>

#### 11.2.2 파일 내용

.h가 여러 추상화를 선언하는 경우 파일 수준 주석은 파일의 내용과 추상화가 어떻게 관련되어 있는지 광범위하게 설명해야 합니다. 1~2 문장의 파일 수준 주석으로 충분할 수 있습니다. 개별 추상화에 대한 자세한
문서는 파일 수준이 아니라 해당 추상화에 속합니다.

.h와 .cc 모두에 주석을 중복하지 마십시오. 중복된 주석은 엇갈립니다.

<a id="s11-3-class-comments"></a>

### 11.3 클래스 주석

명확하지 않은 모든 클래스 또는 구조체 선언에는 용도와 사용 방법을 설명하는 주석이 수반되어야 합니다.

```cpp
// Iterates over the contents of a GargantuanTable.
// Example:
//    std::unique_ptr<GargantuanTableIterator> iter = table->NewIterator();
//    for (iter->Seek("foo"); !iter->done(); iter->Next()) {
//      process(iter->key(), iter->value());
//    }
class GargantuanTableIterator {
  ...
};
```

클래스 설명은 클래스를 올바르게 사용하는 데 필요한 추가 고려 사항뿐만 아니라 클래스를 사용하는 방법과 시기를 알 수 있는 충분한 정보를 독자에게 제공해야 합니다. 클래스가 만드는 동기화 가정(있는 경우)을
문서화합니다. 다중 스레드에서 클래스의 인스턴스에 액세스할 수 있는 경우 다중 스레드 사용을 둘러싼 규칙 및 불변성을 문서화하는 데 각별히 주의하십시오.

클래스 주석은 종종 클래스의 단순하고 집중적인 사용을 보여주는 작은 예제 코드 스니펫을 위한 좋은 위치입니다.

충분히 분리된 경우(예: .h 및 .cc 파일) 클래스 사용을 설명하는 주석은 해당 인터페이스 정의와 함께 이동해야 합니다. 클래스 작업 및 구현에 대한 설명은 클래스 메서드 구현과 함께 제공되어야 합니다.

<a id="s11-4-function-comments"></a>

### 11.4 함수

선언 주석은 함수의 사용을 설명합니다(명백하지 않은 경우). 함수 정의에 있는 주석은 작업을 설명합니다.

<a id="s11-4-1-function-declarations"></a>

#### 11.4.1 함수 선언

거의 모든 함수 선언에는 함수가 수행하는 작업과 사용 방법을 설명하는 주석이 바로 앞에 있어야 합니다. 이러한 주석은 함수가 단순하고 명확한 경우에만 생략될 수 있습니다(예: 클래스의 명백한 속성에 대한 간단한
접근자). 파일 에 선언된 전용 메서드 및 함수는 .cc예외가 아닙니다. 함수 주석은 This function 이라는 암시적 제목으로 작성해야 하며 동사구로 시작해야 합니다.
일반적으로 이러한 주석은 함수가 작업을 수행하는 방법을 설명하지 않습니다. 대신 함수 정의의 주석으로 남겨두어야 합니다.

```cpp
// Returns an iterator for this table, positioned at the first entry
// lexically greater than or equal to `start_word`. If there is no
// such entry, returns a null pointer. The client must not use the
// iterator after the underlying GargantuanTable has been destroyed.
//
// This method is equivalent to:
//    std::unique_ptr<Iterator> iter = table->NewIterator();
//    iter->Seek(start_word);
//    return iter;
std::unique_ptr<Iterator> GetIterator(absl::string_view start_word) const;
```

그러나 불필요하게 장황하거나 완전히 명백한 것을 진술하지 마십시오.

함수 재정의를 문서화할 때 재정의된 함수의 설명을 반복하기보다는 재정의 자체의 세부 사항에 집중하세요. 대부분의 경우 재정의에는 추가 문서가 필요하지 않으므로 설명이 필요하지 않습니다.

생성자와 소멸자에 주석을 달 때 코드를 읽는 사람은 생성자와 소멸자가 무엇인지 알고 있으므로 "이 개체를 파괴합니다"와 같은 주석은 유용하지 않습니다. 생성자가 인수로 수행하는 작업(예: 포인터 소유권을 갖는 경우)
과 소멸자가 수행하는 정리를 문서화합니다. 이것이 사소한 경우 주석을 건너 뛰십시오. 소멸자가 헤더 주석을 갖지 않는 것은 매우 일반적입니다.

<a id="s11-4-1-function-definitions"></a>

#### 11.4.2 함수 정의

함수가 작업을 수행하는 방법에 대해 까다로운 부분이 있는 경우 함수 정의에 설명 주석이 있어야 합니다. 예를 들어, 정의 주석에서 사용하는 모든 코딩 요령을 설명하거나, 수행하는 단계에 대한 개요를 제공하거나, 실행
가능한 대안을 사용하지 않고 수행한 방식으로 함수를 구현하기로 선택한 이유를 설명할 수 있습니다. 예를 들어 함수의 전반부에서는 잠금을 획득해야 하지만 후반부에서는 잠금이 필요하지 않은 이유를 언급할 수 있습니다.

.h 파일이나 어디에서나 함수 선언과 함께 제공된 주석을 반복해서는 안 됩니다. 함수가 하는 일을 간략하게 요약하는 것은 괜찮지만 주석의 초점은 함수가 수행하는 방식에 있어야 합니다.

<a id="s11-5-variable-comments"></a>

### 11.5 변수 주석

일반적으로 변수의 실제 이름은 변수가 사용되는 대상에 대한 좋은 아이디어를 제공하기에 충분히 설명적이어야 합니다. 어떤 경우에는 더 많은 설명이 필요합니다.

<a id="s11-5-1-class-data-members"></a>

#### 11.5.1 클래스 멤버

각 클래스 데이터 멤버(인스턴스 변수 또는 멤버 변수라고도 함)의 용도는 명확해야 합니다. 타입과 이름으로 명확하게 표현되지 않는 불변성(특수 값, 멤버 간 관계, 평생 요구 사항)이 있는 경우 주석을 달아야
합니다. 단, 종류와 이름만 충분하면( int num_events_;) 주석을 달 필요가 없다.

특히, nullptr 또는 -1과 같은 센티넬 값이 명확하지 않은 경우 해당 값의 존재 및 의미를 설명하는 주석을 추가합니다

```cpp
private:
 // Used to bounds-check table accesses. -1 means
 // that we don't yet know how many entries the table has.
 int num_total_entries_;
```

<a id="s11-5-1-global-variables"></a>

#### 11.5.2 전역 변수

모든 전역 변수에는 변수가 무엇인지, 무엇을 위해 사용되는지, 왜 전역 변수여야 하는지 설명하는 주석이 있어야 합니다.

```cpp
// The total number of test cases that we run through in this regression test.
const int kNumTestCases = 6;
```

<a id="s11-6-implementation-comments"></a>

### 11.6 구현 주석

구현 시 까다롭거나 명확하지 않거나 흥미롭거나 중요한 코드 부분에 주석이 있어야 합니다.

<a id="s11-6-1-function-argument-comments"></a>

#### 11.6.1 함수 인자 주석

함수 인수의 의미가 명확하지 않은 경우 다음 해결 방법 중 하나를 고려하십시오.

- 인수가 리터럴 상수이고 동일한 상수가 동일하다고 암묵적으로 가정하는 방식으로 여러 함수 호출에서 동일한 상수가 사용되는 경우 명명된 상수를 사용하여 해당 제약 조건을 명시적으로 만들고 유지되도록 보장해야 합니다.
- bool 인수를 인수로 바꾸려면 함수 서명을 변경하는 것이 좋습니다 enum. 이렇게 하면 인수 값이 자체 설명이 됩니다.
- 여러 구성 옵션이 있는 함수의 경우 단일 클래스 또는 구조체를 정의하여 모든 옵션을 보유하고 해당 인스턴스를 전달하는 것을 고려하십시오. 이 접근 방식에는 몇 가지 장점이 있습니다. 옵션은 호출 사이트에서
  이름으로 참조되며 그 의미를 명확히 합니다. 또한 함수 인수 수를 줄여 함수 호출을 더 쉽게 읽고 쓸 수 있습니다. 추가 혜택으로 다른 옵션을 추가할 때 호출 사이트를 변경할 필요가 없습니다.
- 크거나 복잡한 중첩 표현식을 명명된 변수로 바꿉니다.
- 최후의 수단으로 주석을 사용하여 호출 사이트에서 인수 의미를 명확히 하십시오.

다음 예를 고려하십시오.

```cpp
// What are these arguments?
const DecimalNumber product = CalculateProduct(values, 7, false, nullptr);
```

vs

```cpp
ProductOptions options;
options.set_precision_decimals(7);
options.set_use_cache(ProductOptions::kDontUseCache);
const DecimalNumber product =
    CalculateProduct(values, options, /*completion_callback=*/nullptr);
```

<a id="s11-6-2-do-not"></a>

#### 11.6.2 금지 사항

명백한 것을 진술하지 마십시오.
특히, C++을 잘 이해하는 독자에게 동작이 명확하지 않은 경우가 아니면 코드의 기능을 문자 그대로 설명하지 마십시오. 대신 코드가 수행하는 작업을 수행하는 이유를 설명하는 더 높은 수준의 주석을 제공하거나 코드를
자체 설명하도록 만드십시오.

이것을 비교하십시오:

```cpp
// Find the element in the vector.  <-- Bad: obvious!
if (std::find(v.begin(), v.end(), element) != v.end()) {
  Process(element);
}
```

대신에

```cpp
// Process "element" unless it was already processed.
if (std::find(v.begin(), v.end(), element) != v.end()) {
  Process(element);
}
```

자체 설명 코드에는 주석이 필요하지 않습니다. 위 예의 주석은 분명합니다.

```cpp
if (!IsAlreadyProcessed(element)) {
  Process(element);
}
```

<a id="s11-7-punctuation-spelling-and-grammar"></a>

### 11.7 구두점, 철자 및 문법

구두점, 철자 및 문법에 주의를 기울이십시오. 잘못 작성된 댓글보다 잘 작성된 댓글을 읽는 것이 더 쉽습니다.

댓글은 적절한 대문자와 구두점을 사용하여 내러티브 텍스트처럼 읽을 수 있어야 합니다. 많은 경우 완전한 문장이 문장 조각보다 더 읽기 쉽습니다. 코드 줄 끝에 있는 주석과 같은 짧은 주석은 때때로 덜 형식적일 수
있지만 스타일에 일관성을 유지해야 합니다.

코드 검토자가 세미콜론을 사용해야 할 때 쉼표를 사용하고 있다고 지적하면 실망스러울 수 있지만 소스 코드가 높은 수준의 명확성과 가독성을 유지하는 것이 매우 중요합니다. 적절한 구두점, 철자법 및 문법은 이러한
목표를 달성하는 데 도움이 됩니다.

<a id="s11-8-todo-comments"></a>

### 11.8 TODO 주석

일시적인 코드, 단기 솔루션 또는 충분하지만 완벽하지는 않은 코드에는 TODO 주석을 사용하십시오.

TODO는 모두 대문자로 된 TODO 문자열을 포함해야 하며 그 뒤에 이름, 전자 메일 주소, 버그 ID 또는 TODO가 참조하는 문제에 대한 최상의 컨텍스트가 있는 사람 또는 문제의 기타 식별자가 옵니다. 주요
목적은 요청 시 더 자세한 정보를 얻는 방법을 찾기 위해 검색할 수 있는 일관된 TODO를 갖는 것입니다. TODO는 언급된 사람이 문제를 해결할 것이라는 약속이 아닙니다. 따라서 이름으로 TODO를 만들면 거의
항상 이름이 지정됩니다.

```cpp
// TODO(kl@gmail.com): Use a "*" here for concatenation operator.
// TODO(Zeke) change this to use relations.
// TODO(bug 12345): remove the "Last visitors" feature.
```

TODO가 "At a future date do something" 형식인 경우 매우 구체적인 날짜("2005년 11월까지 수정") 또는 매우 구체적인 이벤트("모든 클라이언트가 XML 응답을 처리할 수 있을 때 이
코드 제거")를 포함해야 합니다. .").

<a id="s12-formatting"></a>

## 12 서식

코딩 스타일과 형식은 매우 임의적이지만 모든 사람이 동일한 스타일을 사용하면 프로젝트를 훨씬 쉽게 따라갈 수 있습니다. 개인은 서식 규칙의 모든 측면에 동의하지 않을 수 있으며 일부 규칙은 익숙해지는 데 어느 정도
시간이 걸릴 수 있지만 모든 프로젝트 기여자가 모든 사람의 코드를 쉽게 읽고 이해할 수 있도록 스타일 규칙을 따르는 것이 중요합니다.

<a id="s12-1-line-length"></a>

### 12.1 줄 길이

코드의 각 텍스트 줄은 최대 80자여야 합니다.

우리는 이 규칙이 논란의 여지가 있다는 것을 알고 있지만 이미 많은 기존 코드가 이 규칙을 준수하고 있으며 일관성이 중요하다고 생각합니다.

장점:  
이 규칙을 선호하는 사람들은 창 크기를 조정하도록 강요하는 것은 무례한 일이며 더 이상 그럴 필요가 없다고 주장합니다. 일부 사람들은 여러 개의 코드 창을 나란히 사용하는 데 익숙하므로 어떤 경우에도 창을 넓힐
공간이 없습니다. 사람들은 특정 최대 창 너비를 가정하여 작업 환경을 설정하고 80 열이 기존 표준이었습니다

단점:  
변화를 지지하는 사람들은 줄이 더 넓어지면 코드를 더 읽기 쉽게 만들 수 있다고 주장합니다. 80개 열 제한은 1960년대 메인프레임에 대한 은밀한 후퇴입니다. 최신 장비에는 더 긴 라인을 쉽게 보여줄 수 있는
와이드 스크린이 있습니다.

결론:  
최대 80자입니다.

한 줄은 다음과 같은 경우 80자를 초과할 수 있습니다.

- 가독성, 잘라내기 및 붙여넣기 용이성 또는 자동 링크를 해치지 않고 분할할 수 없는 주석 행 -- 예를 들어 행에 예제 명령이 포함되어 있거나 80자를 초과하는 리터럴 URL이 있는 경우.
- 80 열에서 쉽게 래핑할 수 없는 문자열 리터럴입니다. 이는 URI 또는 기타 의미론적으로 중요한 부분을 포함하거나 리터럴에 포함된 언어 또는 새 줄이 도움말 메시지와 같이 중요한 여러 줄 리터럴을 포함하기
  때문일 수 있습니다. 이러한 경우 리터럴을 분할하면 가독성, 검색 가능성, 링크 클릭 기능 등이 감소합니다. 테스트 코드를 제외하고 이러한 리터럴은 파일 상단 근처의 네임스페이스 범위에 나타나야 합니다.
  Clang-Format과 같은 도구가 분할할 수 없는 콘텐츠를 인식하지 못하는 경우 필요에 따라 콘텐츠 주변의 도구를 비활성화합니다.
  (우리는 이러한 리터럴의 유용성/검색 가능성과 주변 코드의 가독성 사이에서 균형을 유지해야 합니다.)
- include 문
- header guard
- 사용 선언

<a id="s12-2-non-ascll-characters"></a>

### 12.2 비 SCII 문자

ASCII가 아닌 문자는 거의 사용하지 않으며 UTF-8 형식을 사용해야 합니다.

소스에 사용자에게 표시되는 텍스트(영어 포함)를 하드 코딩하면 안 되므로 ASCII가 아닌 문자를 사용하는 경우는 드뭅니다. 그러나 경우에 따라 코드에 이러한 단어를 포함하는 것이 적절합니다. 예를 들어 코드가 외부
소스의 데이터 파일을 구문 분석하는 경우 해당 데이터 파일에서 구분 기호로 사용되는 비ASCII 문자열을 하드 코딩하는 것이 적절할 수 있습니다. 보다 일반적으로 단위 테스트 코드(지역화할 필요가 없음)에는
ASCII가 아닌 문자열이 포함될 수 있습니다. 이러한 경우 UTF-8을 사용해야 합니다. UTF-8은 ASCII보다 더 많은 것을 처리할 수 있는 대부분의 도구에서 이해하는 인코딩이기 때문입니다.

16진수 인코딩도 가능하며 가독성을 향상시키는 경우 권장됩니다. 스트레이트 UTF-8로 소스에 포함된 경우 보이지 않습니다.

가능하면 u8 접두사를 사용하지 마십시오. 이것은 C++17에서보다 C++20에서 시작하여 char 대신 char8_t의 배열을 생성하는 상당히 다른 의미 체계를 가집니다.

UTF-8이 아닌 텍스트용이므로 char16_t 및 char32_t 문자 유형을 사용하면 안 됩니다. 비슷한 이유로 wchar_t도 사용하면 안 됩니다(wchar_t를 광범위하게 사용하는 Windows API와 상호
작용하는 코드를 작성하지 않는 한).

<a id="s12-3-space-vs-tabs"></a>

### 12.3 스페이스 vs 탭

공백만 사용하고 한 번에 2칸씩 들여쓰기합니다.

우리는 들여쓰기를 위해 공백을 사용합니다. 코드에서 탭을 사용하지 마십시오. 탭 키를 누를 때 공백을 내보내도록 편집기를 설정해야 합니다.

<a id="s12-4-function-declarations-and-definitions"></a>

### 12.4 함수 선언과 정의

함수 이름과 같은 줄에 유형을 반환하고 매개변수가 맞는 경우 같은 줄에 반환합니다. 함수 호출에서 인수를 래핑하는 것처럼 한 줄에 맞지 않는 매개변수 목록을 래핑합니다.

```cpp
ReturnType ClassName::FunctionName(Type par_name1, Type par_name2) {
  DoSomething();
  ...
}
```

한 줄에 맞추기에는 너무 많은 텍스트가 있는 경우:

```cpp
ReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2,
                                             Type par_name3) {
  DoSomething();
  ...
}
```

또는 첫 번째 매개변수도 맞출 수 없는 경우:

```cpp
ReturnType LongClassName::ReallyReallyReallyLongFunctionName(
    Type par_name1,  // 4 space indent
    Type par_name2,
    Type par_name3) {
  DoSomething();  // 2 space indent
  ...
}
```

몇 가지 참고 사항:

- 좋은 매개변수 이름을 선택하십시오.
- 함수 정의에서 매개변수를 사용하지 않는 경우에만 매개변수 이름을 생략할 수 있습니다.
- 반환 유형과 함수 이름을 한 줄에 맞출 수 없으면 둘 사이를 끊습니다.
- 함수 선언 또는 정의의 반환 유형 다음에 중단하는 경우 들여쓰지 마십시오.
- 여는 괄호는 항상 함수 이름과 같은 줄에 있습니다.
- 함수 이름과 여는 괄호 사이에는 공백이 없습니다.
- 괄호와 매개변수 사이에는 공백이 없습니다.
- 여는 중괄호는 항상 다음 줄의 시작이 아니라 함수 선언의 마지막 줄 끝에 있습니다.
- 닫는 중괄호는 마지막 줄에 단독으로 있거나 여는 중괄호와 같은 줄에 있습니다.
- 닫는 괄호와 여는 중괄호 사이에는 공백이 있어야 합니다.
- 가능하면 모든 매개변수를 정렬해야 합니다.
- 기본 들여쓰기는 2칸입니다.
- 래핑된 매개변수에는 4칸 들여쓰기가 있습니다.

사용하지 않는 매개변수는 문맥에서 분명하게 생략할 수 있습니다.

```cpp
class Foo {
 public:
  Foo(const Foo&) = delete;
  Foo& operator=(const Foo&) = delete;
};
```

명확하지 않을 수 있는 사용되지 않은 매개변수는 함수 정의에서 변수 이름을 주석 처리해야 합니다.

```cpp
class Shape {
 public:
  virtual void Rotate(double radians) = 0;
};

class Circle : public Shape {
 public:
  void Rotate(double radians) override;
};

void Circle::Rotate(double /*radians*/) {}
```

```cpp
// Bad - if someone wants to implement later, it's not clear what the
// variable means.
void Circle::Rotate(double) {}
```

속성 및 속성으로 확장되는 매크로는 함수 선언 또는 정의의 맨 처음, 반환 유형 앞에 나타납니다.

```cpp
  ABSL_ATTRIBUTE_NOINLINE void ExpensiveFunction();
  [[nodiscard]] bool IsOk();
```

<a id="s12-5-lambda-expressions"></a>

### 12.5 람다 표현식

다른 함수와 마찬가지로 매개변수와 본문의 형식을 지정하고 다른 쉼표로 구분된 목록과 같은 목록을 캡처합니다.

참조에 의한 캡처의 경우 앰퍼샌드(&)와 변수 이름 사이에 공백을 두지 마십시오.

```cpp
int x = 0;
auto x_plus_n = [&x](int n) -> int { return x + n; }
```

짧은 람다는 함수 인수로 인라인으로 작성될 수 있습니다.

```cpp
absl::flat_hash_set<int> to_remove = {7, 8, 9};
std::vector<int> digits = {3, 9, 1, 8, 4, 7, 1};
digits.erase(std::remove_if(digits.begin(), digits.end(), [&to_remove](int i) {
               return to_remove.contains(i);
             }),
             digits.end());
```

<a id="s12-6-floating-point-literals"></a>

### 12.6 부동 소수점 리터럴

부동 소수점 리터럴은 지수 표기법을 사용하더라도 항상 기수가 있어야 하며 양쪽에 숫자가 있어야 합니다. 모든 부동 소수점 리터럴이 이 친숙한 형식을 취하면 가독성이 향상됩니다. 이는 부동 소수점 리터럴이 정수
리터럴로 오인되지 않고 지수 표기법의 E/ e가 16진수로 오인되지 않도록 하는 데 도움이 되기 때문입니다. 정수 리터럴로 부동 소수점 변수를 초기화하는 것은 괜찮지만(변수 유형이 해당 정수를 정확하게 나타낼 수
있다고 가정) 지수 표기법의 숫자는 정수 리터럴이 아닙니다.

```cpp
float f = 1.f;
long double ld = -.5L;
double d = 1248e6;
```

```cpp
float f = 1.0f;
float f2 = 1;   // Also OK
long double ld = -0.5L;
double d = 1248.0e6;
```

<a id="s12-7-function-calls"></a>

### 12.7 함수 호출

호출을 모두 한 줄에 쓰거나, 인수를 괄호로 묶거나, 인수를 공백 4개로 들여쓴 새 줄에서 시작하고 해당 4개 공백 들여쓰기에서 계속합니다. 다른 고려 사항이 없는 경우에는 적절한 경우 각 줄에 여러 인수를 배치하는
것을 포함하여 최소 줄 수를 사용하십시오.

```cpp
bool result = DoSomething(argument1, argument2, argument3);
```

인수가 모두 한 줄에 맞지 않으면 여러 줄로 나누어야 하며 각 후속 줄은 첫 번째 인수에 맞춰야 합니다. 여는 괄호 뒤나 닫는 괄호 앞에 공백을 추가하지 마십시오.

```cpp
bool result = DoSomething(averyveryveryverylongargument1, 
                          argument2, argument3);
```

인수는 선택적으로 4칸 들여쓰기로 다음 줄에 모두 배치할 수 있습니다.

```cpp
if (...) { 
  ... 
  ... 
  if (...) { 
    bool result = DoSomething( 
        argument1, argument2, // 4 공백 들여쓰기 
        argument3, argument4); 
    ... 
  }
```

정 가독성 문제가 없는 한 함수를 호출하는 데 필요한 줄 수를 줄이기 위해 한 줄에 여러 인수를 넣습니다. 어떤 사람들은 각 줄에 하나의 인수를 엄격하게 사용하는 형식이 더 읽기 쉽고 인수 편집을 단순화한다고
생각합니다. 그러나 우리는 인수 편집의 용이성보다 독자를 우선시하며 대부분의 가독성 문제는 다음 기술로 더 잘 해결됩니다.

한 줄에 여러 인수가 있는 경우 일부 인수를 구성하는 식의 복잡성 또는 혼란스러운 특성으로 인해 가독성이 떨어지는 경우 해당 인수를 설명하는 이름으로 캡처하는 변수를 만들어 보십시오.

```cpp
int my_heuristic = scores[x] * y + bases[x];
bool result = DoSomething(my_heuristic, x, y, z);
```

또는 설명 주석과 함께 혼란스러운 주장을 한 줄에 넣습니다.

```cpp
bool result = DoSomething(scores[x] * y + bases[x],  // Score heuristic.
                          x, y, z);
```

하나의 인수가 자체 라인에서 훨씬 더 읽기 쉬운 경우가 여전히 있는 경우 자체 라인에 배치하십시오. 결정은 일반적인 정책보다는 더 읽기 쉬운 논거에 대해 구체적이어야 합니다.

때때로 인수는 가독성에 중요한 구조를 형성합니다. 이러한 경우 해당 구조에 따라 인수의 형식을 자유롭게 지정할 수 있습니다.

```cpp
// Transform the widget by a 3x3 matrix.
my_widget.Transform(x1, x2, x3,
                    y1, y2, y3,
                    z1, z2, z3);
```

<a id="s12-8-braced-initializer-list-format"></a>

### 12.8 중괄호 이니셜라이저 목록 형식

그 자리에서 함수 호출의 형식을 지정하는 것과 똑같이 중괄호로 묶인 초기화 목록의 형식을 지정합니다.

{}중괄호 목록이 이름(예: 유형 또는 변수 이름) 뒤에 오는 경우 해당 이름을 가진 함수 호출의 괄호인 것처럼 형식을 지정합니다.
이름이 없으면 길이가 0인 이름을 가정합니다.

```cpp
// Examples of braced init list on a single line.
return {foo, bar};
functioncall({foo, bar});
std::pair<int, int> p{foo, bar};

// When you have to wrap.
SomeFunction(
    {"assume a zero-length name before {"},
    some_other_function_parameter);
SomeType variable{
    some, other, values,
    {"assume a zero-length name before {"},
    SomeOtherType{
        "Very long string requiring the surrounding breaks.",
        some, other, values},
    SomeOtherType{"Slightly shorter string",
                  some, other, values}};
SomeType variable{
    "This is too long to fit all in one line"};
MyType m = {  // Here, you could also break before {.
    superlongvariablename1,
    superlongvariablename2,
    {short, interior, list},
    {interiorwrappinglist,
     interiorwrappinglist2}};
```

<a id="s12-9-looping-and-branching-statements"></a>

#### 12.9 반복 및 분기문

높은 수준에서 루프 또는 분기 문은 다음 구성 요소 로 구성됩니다 .

- 하나 이상의 명령문 키워드 (예 if: , else, switch, while, do, 또는 for).
- 괄호 안에 하나의 조건 또는 반복 지정자
- 하나 이상의 제어문 또는 제어문 블록

이러한 진술의 경우:

- 문의 구성 요소는 단일 공백으로 구분해야 합니다(줄 바꿈 아님).
- 조건 또는 반복 지정자 내에서 토큰이 닫는 괄호나 다른 세미콜론인 경우를 제외하고 각 세미콜론과 다음 토큰 사이에 하나의 공백(또는 줄 바꿈)을 넣습니다.
- 조건 또는 반복 지정자 내에서 여는 괄호 뒤나 닫는 괄호 앞에 공백을 넣지 마십시오.
- 제어문을 블록 안에 넣습니다(예: 중괄호 사용).
- 제어 블록 내에서 여는 중괄호 바로 뒤에 한 줄 바꿈을 넣고 닫는 중괄호 바로 앞에 한 줄 바꿈을 넣습니다.

```cpp
if (condition) {                   // Good - no spaces inside parentheses, space before brace.
  DoOneThing();                    // Good - two-space indent.
  DoAnotherThing();
} else if (int a = f(); a != 3) {  // Good - closing brace on new line, else on same line.
  DoAThirdThing(a);
} else {
  DoNothing();
}

// Good - the same rules apply to loops.
while (condition) {
  RepeatAThing();
}

// Good - the same rules apply to loops.
do {
  RepeatAThing();
} while (condition);

// Good - the same rules apply to loops.
for (int i = 0; i < 10; ++i) {
  RepeatAThing();
}
```

```cpp
if(condition) {}                   // Bad - space missing after `if`.
else if ( condition ) {}           // Bad - space between the parentheses and the condition.
else if (condition){}              // Bad - space missing before `{`.
else if(condition){}               // Bad - multiple spaces missing.

for (int a = f();a == 10) {}       // Bad - space missing after the semicolon.

// Bad - `if ... else` statement does not have braces everywhere.
if (condition)
  foo;
else {
  bar;
}

// Bad - `if` statement too long to omit braces.
if (condition)
  // Comment
  DoSomething();

// Bad - `if` statement too long to omit braces.
if (condition1 &&
    condition2)
  DoSomething();
```

역사적인 이유로 위의 규칙에 대한 한 가지 예외를 허용합니다. 제어 명령문의 중괄호 또는 중괄호 안의 줄 바꿈은 결과적으로 전체 명령문이 한 줄에 나타나는 경우 생략될 수 있습니다(이 경우 닫는 괄호와 제어 문
사이의 공백) 또는 두 줄(이 경우 닫는 괄호 뒤에 줄바꿈이 있고 중괄호가 없음).

```cpp
// OK - fits on one line.
if (x == kFoo) { return new Foo(); }

// OK - braces are optional in this case.
if (x == kFoo) return new Foo();

// OK - condition fits on one line, body fits on another.
if (x == kBar)
  Bar(arg1, arg2, arg3);
```

이 예외는 if ... else 또는 do ... while과 같은 다중 키워드 문에는 적용되지 않습니다.

```cpp
// Bad - `if ... else` statement is missing braces.
if (x) DoThis();
else DoThat();

// Bad - `do ... while` statement is missing braces.
do DoThis();
while (x);
```

명령문이 간단한 경우에만 이 스타일을 사용하고 복잡한 조건 또는 제어 명령문이 있는 루프 및 분기 명령문은 중괄호를 사용하면 더 읽기 쉽습니다. 일부 프로젝트에는 항상 중괄호가 필요합니다.

switch 문의 case 블록은 기본 설정에 따라 중괄호를 포함하거나 포함하지 않을 수 있습니다. 중괄호를 포함하는 경우 아래와 같이 배치해야 합니다.

```cpp
switch (var) {
  case 0: {  // 2 space indent
    Foo();   // 4 space indent
    break;
  }
  default: {
    Bar();
  }
}
```

빈 루프 본문은 빈 중괄호 쌍을 사용하거나 단일 세미콜론이 아닌 중괄호 없이 계속해야 합니다.

```cpp
while (condition) {}  // Good - `{}` indicates no logic.
while (condition) {
  // Comments are okay, too
}
while (condition) continue;  // Good - `continue` indicates no logic.
```

```cpp
while (condition);  // Bad - looks like part of `do-while` loop.
```

<a id="s12-10-pointer-and-reference-expressions"></a>

### 12.10 포인터 및 참조 표현식

마침표나 화살표 주위에 공백이 없습니다. 포인터 연산자에는 후행 공백이 없습니다.

다음은 올바른 형식의 포인터 및 참조 식의 예입니다.

```cpp
x = *p; 
p = &x; 
x = ry; 
x = r->y;
```

참고:

- 멤버에 액세스할 때 마침표나 화살표 주위에 공백이 없습니다.
- 포인터 연산자는 * 또는 & 뒤에 공백이 없습니다.

포인터 또는 참조(변수 선언 또는 정의, 인수, 반환 유형, 템플릿 매개 변수 등)를 참조할 때 별표/앰퍼샌드 앞이나 뒤에 공백을 둘 수 있습니다. 후행 공백 스타일에서는 경우에 따라 공백이 생략됩니다(템플릿
매개변수 등).

```cpp
// These are fine, space preceding.
char *c;
const std::string &str;
int *GetPointer();
std::vector<char *>

// These are fine, space following (or elided).
char* c;
const std::string& str;
int* GetPointer();
std::vector<char*>  // Note no space between '*' and '>'
```

단일 파일 내에서 일관되게 이 작업을 수행해야 합니다. 기존 파일을 수정할 때 해당 파일의 스타일을 사용하십시오.

동일한 선언에서 여러 변수를 선언하는 것이 허용되지만(비정상적인 경우) 포인터 또는 참조 데코레이션이 있는 경우 허용되지 않습니다. 이러한 선언은 쉽게 오독됩니다.

```cpp
// Fine if helpful for readability.
int x, y;
```

```cpp
int x, *y;  // Disallowed - no & or * in multiple declaration
int* x, *y;  // Disallowed - no & or * in multiple declaration; inconsistent spacing
char * c;  // Bad - spaces on both sides of *
const std::string & str;  // Bad - spaces on both sides of &
```

<a id="s12-11-boolean-expressions"></a>

### 12.11 Boolean 표현식

표준 행 길이보다 긴 부울 표현식이 있는 경우 행을 분할하는 방법에 일관성을 유지하십시오.

이 예에서 논리 AND 연산자는 항상 줄 끝에 있습니다.

```cpp
if (this_one_thing > this_other_thing &&
    a_third_thing == a_fourth_thing &&
    yet_another && last_one) {
  ...
}
```

이 예제에서 코드가 줄바꿈될 때 && 논리 AND 연산자는 모두 줄 끝에 있습니다. 줄의 시작 부분에서 모든 연산자를 래핑하는 것도 허용되지만 이는 Google 코드에서 더 일반적입니다. 적절하게 사용하면 가독성을
높이는 데 큰 도움이 될 수 있으므로 추가 괄호를 신중하게 삽입하되 남용에 주의하세요. 또한 and 및 compl과 같은 단어 연산자 대신 && 및 ~와 같은 구두점 연산자를 항상 사용해야 합니다.

<a id="s12-12-return-values"></a>

### 12.12 반환값

반환 식을 불필요하게 괄호로 묶지 마십시오.

```cpp
return result;                  // No parentheses in the simple case.
// Parentheses OK to make a complex expression more readable.
return (some_long_condition &&
        another_condition);
```

```cpp
return (value);                // You wouldn't write var = (value);
return(result);                // return is not a function!
```

<a id="s12-13-variable-and-array-initialization"></a>

### 12.13 변수 및 배열 초기화

=, () 및 {} 중에서 선택할 수 있습니다. 다음은 모두 정확합니다.

```cpp
int x = 3;
int x(3);
int x{3};
std::string name = "Some Name";
std::string name("Some Name");
std::string name{"Some Name"};
```

std::initializer_list 생성자가 있는 유형에서 중괄호 초기화 목록 {...}을 사용할 때 주의하십시오. 비어 있지 않은 중괄호 초기화 목록은 가능할 때마다 std::initializer_list
생성자를 선호합니다. 빈 중괄호 {}는 특별하며 사용 가능한 경우 기본 생성자를 호출합니다. 비 std::initializer_list 생성자를 강제하려면 중괄호 대신 괄호를 사용하십시오.

```cpp
std::vector<int> v(100, 1);  // A vector containing 100 items: All 1s.
std::vector<int> v{100, 1};  // A vector containing 2 items: 100 and 1.
```

또한 중괄호 형식은 정수 유형의 축소를 방지합니다. 이렇게 하면 일부 유형의 프로그래밍 오류를 방지할 수 있습니다.

```cpp
int pi(3.14);  // OK -- pi == 3.
int pi{3.14};  // Compile error: narrowing conversion.
```

<a id="s12-14-preprocessor-directives"></a>

### 12.14 전처리기 지시문

전처리기 지시문을 시작하는 해시 마크는 항상 줄의 시작 부분에 있어야 합니다.

전처리기 지시문이 들여쓰기된 코드 본문 내에 있더라도 지시문은 줄의 시작 부분에서 시작해야 합니다.

```cpp
// Good - directives at beginning of line
  if (lopsided_score) {
#if DISASTER_PENDING      // Correct -- Starts at beginning of line
    DropEverything();
# if NOTIFY               // OK but not required -- Spaces after #
    NotifyClient();
# endif
#endif
    BackToNormal();
  }
```

```cpp
// Bad - indented directives
  if (lopsided_score) {
    #if DISASTER_PENDING  // Wrong!  The "#if" should be at beginning of line
    DropEverything();
    #endif                // Wrong!  Do not indent "#endif"
    BackToNormal();
  }
```

<a id="s12-15-class-format"></a>

### 12.15 클래스 서식

공용, 보호 및 개인 순서의 섹션은 각각 한 칸씩 들여쓰기됩니다.

클래스 정의의 기본 형식(주석이 없음, 어떤 주석이 필요한지에 대한 논의는 클래스 주석 참조)은 다음과 같습니다.

```cpp
class MyClass : public OtherClass {
 public:      // Note the 1 space indent!
  MyClass();  // Regular 2 space indent.
  explicit MyClass(int var);
  ~MyClass() {}

  void SomeFunction();
  void SomeFunctionThatDoesNothing() {
  }

  void set_some_var(int var) { some_var_ = var; }
  int some_var() const { return some_var_; }

 private:
  bool SomeInternalFunction();

  int some_var_;
  int some_other_var_;
};
```

참고 사항:

- 모든 기본 클래스 이름은 80열 제한에 따라 하위 클래스 이름과 같은 줄에 있어야 합니다.
- public:, protected: 및 private: 키워드는 한 칸 들여써야 합니다.
- 첫 번째 인스턴스를 제외하고 이러한 키워드 앞에는 빈 줄이 있어야 합니다. 이 규칙은 소규모 학급에서는 선택 사항입니다.
- 이 키워드 뒤에 빈 줄을 두지 마십시오.
- public 섹션이 먼저 오고 그 다음에는 protected 섹션이 오고 마지막으로 private 섹션이 옵니다.

<a id="s12-16-constructor-initializer-lists"></a>

### 12.16 생성자 초기화 목록

생성자 이니셜라이저 목록은 모두 한 줄에 있거나 후속 줄이 4칸 들여쓰기될 수 있습니다.

이니셜라이저 목록에 허용되는 형식은 다음과 같습니다.

```cpp
// When everything fits on one line:
MyClass::MyClass(int var) : some_var_(var) {
  DoSomething();
}

// If the signature and initializer list are not all on one line,
// you must wrap before the colon and indent 4 spaces:
MyClass::MyClass(int var)
    : some_var_(var), some_other_var_(var + 1) {
  DoSomething();
}

// When the list spans multiple lines, put each member on its own line
// and align them:
MyClass::MyClass(int var)
    : some_var_(var),             // 4 space indent
      some_other_var_(var + 1) {  // lined up
  DoSomething();
}

// As with any other code block, the close curly can be on the same
// line as the open curly, if it fits.
MyClass::MyClass(int var)
    : some_var_(var) {}
```

<a id="s12-17-namespace-formatting"></a>

### 12.17 네임스페이스 서식

임스페이스의 내용은 들여쓰기되지 않습니다.

네임스페이스는 추가 수준의 들여쓰기를 추가하지 않습니다. 예를 들어 다음을 사용합니다.

```cpp
namespace {

void foo() {  // Correct.  No extra indentation within namespace.
  ...
}

}  // namespace
```

네임스페이스 내에서 들여쓰지 마십시오.

```cpp
namespace {

  // Wrong!  Indented when it should not be.
  void foo() {
    ...
  }

}  // namespace
```

<a id="s12-18-horizontal-whitespace"></a>

### 12.18 가로 공백

가로 공백의 사용은 위치에 따라 다릅니다. 줄 끝에 후행 공백을 두지 마십시오.

<a id="s12-18-1-generla"></a>

#### 12.18.1 일반

```cpp
int i = 0;  // Two spaces before end-of-line comments.

void f(bool b) {  // Open braces should always have a space before them.
  ...
int i = 0;  // Semicolons usually have no space before them.
// Spaces inside braces for braced-init-list are optional.  If you use them,
// put them on both sides!
int x[] = { 0 };
int x[] = {0};

// Spaces around the colon in inheritance and initializer lists.
class Foo : public Bar {
 public:
  // For inline function implementations, put spaces between the braces
  // and the implementation itself.
  Foo(int b) : Bar(), baz_(b) {}  // No spaces inside empty braces.
  void Reset() { baz_ = 0; }  // Spaces separating braces from implementation.
  ...
```

후행 공백을 추가하면 기존 후행 공백을 제거할 수 있는 것처럼 병합 시 동일한 파일을 편집하는 다른 사용자에게 추가 작업이 발생할 수 있습니다. 따라서: 후행 공백을 도입하지 마십시오. 이미 해당 줄을 변경하고 있는
경우 제거하거나 별도의 정리 작업에서 수행합니다(다른 사람이 파일에서 작업하지 않을 때 가능).

<a id="s12-18-2-loop-and-conditionals"></a>

#### 12.18.2 반복 및 조건부

```cpp
if (b) {          // Space after the keyword in conditions and loops.
} else {          // Spaces around else.
}
while (test) {}   // There is usually no space inside parentheses.
switch (i) {
for (int i = 0; i < 5; ++i) {
// Loops and conditions may have spaces inside parentheses, but this
// is rare.  Be consistent.
switch ( i ) {
if ( test ) {
for ( int i = 0; i < 5; ++i ) {
// For loops always have a space after the semicolon.  They may have a space
// before the semicolon, but this is rare.
for ( ; i < 5 ; ++i) {
  ...

// Range-based for loops always have a space before and after the colon.
for (auto x : counts) {
  ...
}
switch (i) {
  case 1:         // No space before colon in a switch case.
    ...
```

<a id="s12-18-3-operators"></a>

#### 12.18.3 오퍼레이터

```cpp
// Assignment operators always have spaces around them.
x = 0;

// Other binary operators usually have spaces around them, but it's
// OK to remove spaces around factors.  Parentheses should have no
// internal padding.
v = w * x + y / z;
v = w*x + y/z;
v = w * (x + z);

// No spaces separating unary operators and their arguments.
x = -5;
++x;
if (x && !y)
  ...
```

<a id="s12-18-4-templates-and-casts"></a>

#### 12.18.4 템플릿과 캐스트

```cpp
// No spaces inside the angle brackets (< and >), before
// <, or between >( in a cast
std::vector<std::string> x;
y = static_cast<char*>(x);

// Spaces between type and pointer are OK, but be consistent.
std::vector<char *> x;
```

<a id="s12-19-vertical-whitespace"></a>

### 12.19 세로 공백

세로 공백의 사용을 최소화합니다.

이것은 규칙이라기보다 원칙에 가깝습니다. 필요하지 않을 때는 빈 줄을 사용하지 마세요. 특히, 함수 사이에 빈 줄을 한두 개 이상 넣지 말고, 빈 줄로 함수를 시작하지 말고, 빈 줄로 함수를 끝내지 말고, 빈 줄
사용을 자제하세요. 코드 블록 내의 빈 줄은 두 가지 생각을 시각적으로 구분하는 산문의 단락 나누기 역할을 합니다.

기본 원칙은 다음과 같습니다. 한 화면에 맞는 코드가 많을수록 프로그램의 제어 흐름을 더 쉽게 따르고 이해할 수 있습니다. 의도적으로 공백을 사용하여 해당 흐름에서 분리를 제공합니다.

빈 줄이 유용할 때 도움이 되는 몇 가지 경험 법칙:

- 함수의 시작이나 끝에 있는 빈 줄은 가독성에 도움이 되지 않습니다.
- if-else 블록 체인 내부의 빈 줄은 가독성에 도움이 될 수 있습니다.
- 주석 행 앞의 빈 행은 일반적으로 가독성에 도움이 됩니다. 새 주석의 도입은 새로운 생각의 시작을 암시하며, 빈 행은 주석이 이전 항목 대신 다음 항목과 함께 있음을 분명히 합니다.
- 네임스페이스 또는 네임스페이스 블록의 선언 바로 안에 있는 빈 줄은 (대부분 비의미적) 조직 래퍼에서 로드 베어링 콘텐츠를 시각적으로 분리하여 가독성을 높일 수 있습니다. 특히 네임스페이스 내의 첫 번째 선언
  앞에 주석이 있는 경우 이는 이전 규칙의 특수한 경우가 되어 주석이 후속 선언에 "첨부"되도록 합니다.

<a id="s13-exceptions-to-the-rules"></a>

## 13 예외 규칙

위에서 설명한 코딩 규칙은 필수입니다. 그러나 모든 좋은 규칙과 마찬가지로 여기에는 때때로 예외가 있으며 여기에서 설명합니다.

<a id="s13-1-existing-non-conformant-code"></a>

### 13.1 기존 부적합 코드

이 스타일 가이드를 따르지 않는 코드를 다룰 때 규칙에서 벗어날 수 있습니다.

이 가이드에서 제시한 사양 이외의 사양으로 작성된 코드를 수정하는 경우 해당 코드의 로컬 규칙과 일관성을 유지하기 위해 이러한 규칙에서 벗어나야 할 수 있습니다. 이 작업을 수행하는 방법이 확실하지 않은 경우 원래
작성자나 현재 코드를 담당하는 사람에게 문의하십시오. 일관성에는 로컬 일관성도 포함된다는 점을 기억하십시오.

<a id="s13-2-windows-code"></a>

### 13.2 Windows 코드

Windows 프로그래머는 주로 Windows 헤더 및 기타 Microsoft 코드의 규칙에서 파생된 고유한 코딩 규칙 집합을 개발했습니다. 누구나 쉽게 코드를 이해할 수 있도록 모든 플랫폼에서 C++를 작성하는
모든 사람을 위한 단일 지침 세트가 있습니다.

